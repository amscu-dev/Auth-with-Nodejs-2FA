/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * API for Password, Passkey, Magic Link, and OIDC Authentication
 * API for user registration and authentication using multiple methods: username/password with capability of 2fa, passkey (WebAuthn), magic link, and OIDC providers (Google, GitHub, etc.).

 * OpenAPI spec version: 1.0.0
 */
import * as zod from "zod";

export const passkeySignInInitResponseBody = zod.object({
  success: zod.boolean(),
  statusCode: zod.number(),
  message: zod.string().min(1),
  metadata: zod.object({
    requestId: zod.string(),
    timestamp: zod.iso.datetime(),
  }),
  data: zod.object({
    publicKeyCredentialRequestOptions: zod.object({
      allowCredentials: zod.array(
        zod.object({
          id: zod.string().min(1),
          type: zod.enum(["public-key"]),
          transports: zod.array(
            zod.enum(["ble", "hybrid", "internal", "nfc", "usb"])
          ),
        })
      ),
      challenge: zod.string().min(1),
      rpId: zod.string().min(1),
      timeout: zod.number(),
      userVerification: zod.enum(["required"]),
    }),
  }),
});

export const passkeySignUpInitResponseBody = zod.object({
  success: zod.boolean(),
  statusCode: zod.number(),
  message: zod.string().min(1),
  metadata: zod.object({
    requestId: zod.string(),
    timestamp: zod.iso.datetime(),
  }),
  data: zod.object({
    publicKeyOpts: zod.object({
      attestation: zod.enum(["direct", "enterprise", "indirect", "none"]),
      authenticatorSelection: zod.object({
        requireResidentKey: zod.boolean(),
        residentKey: zod.enum(["required"]),
        userVerification: zod.enum(["required"]),
      }),
      challenge: zod.string().min(1),
      excludeCredentials: zod.array(
        zod.object({
          id: zod.string().min(1),
          type: zod.enum(["public-key"]),
          transports: zod.array(
            zod.enum(["ble", "hybrid", "internal", "nfc", "usb"])
          ),
        })
      ),
      extensions: zod.object({
        credProps: zod.boolean(),
      }),
      hints: zod.array(zod.enum(["hybrid", "security-key", "client-device"])),
      pubKeyCredParams: zod.array(
        zod.object({
          alg: zod.number(),
          type: zod.enum(["public-key"]),
        })
      ),
      rp: zod.object({
        id: zod.string().min(1),
        name: zod.string().min(1),
      }),
      timeout: zod.number(),
      user: zod.object({
        displayName: zod.string().min(1),
        id: zod.string().min(1),
        name: zod.string().min(1),
      }),
    }),
  }),
});

/**
 * Starts the registration process for a new user using passwordless passkey authentication.  The client provides the user's name and email address. If the email is not already registered, the server generates a **PublicKeyCredentialCreationOptions** object required by the WebAuthn API. This object includes a challenge, relying party information, user details, allowed algorithms, and authenticator selection criteria. It must be sent back to the client to complete the registration on the authenticator (device or platform). The server also stores a temporary PasskeyChallengeSession to track the challenge for later verification.

 * @summary Initialize a passkey registration session
 */
export const passkeySignUpInitMutationFnBody = zod.object({
  name: zod
    .string()
    .min(1, { message: "Full name is required" })
    .max(64, {
      message: `Full name must be at most 64 characters`,
    })
    .describe("The user's full name"),

  email: zod
    .string()
    .min(1, { message: "Email is required" })
    .max(64, {
      message: `Email must be at most 64 characters`,
    })
    .email({ message: "Please enter a valid email address" }),
});

/**
 * Verifies a passkey registration session provided by the client to complete the user signup process.
The client must provide a `PasskeyRegistrationResponse` object containing the credential information generated during the passkey registration initiation.

 * @summary Verify a passkey registration session and complete user signup
 */
export const passkeySignUpVerifyMutationFnBody = zod.object({
  id: zod
    .string()
    .describe(
      "Base64Url-encoded credential ID generated by the authenticator."
    ),
  rawId: zod.string().describe("Raw Base64Url-encoded credential ID."),
  type: zod.enum(["public-key"]).describe('Must always be \"public-key\".'),
  response: zod.object({
    attestationObject: zod
      .string()
      .describe(
        "Base64Url-encoded attestation object provided by the authenticator."
      ),
    clientDataJSON: zod
      .string()
      .describe("Base64Url-encoded JSON object with client data."),
    authenticatorData: zod
      .string()
      .optional()
      .describe("Optional authenticator data returned by the device."),
    publicKey: zod
      .string()
      .optional()
      .describe("Optional public key generated by the authenticator."),
    publicKeyAlgorithm: zod
      .number()
      .optional()
      .describe("Optional algorithm identifier for the public key."),
    transports: zod
      .array(
        zod.enum([
          "ble",
          "cable",
          "hybrid",
          "internal",
          "nfc",
          "smart-card",
          "usb",
        ])
      )
      .optional()
      .describe("Optional transport methods supported by the authenticator."),
  }),
  authenticatorAttachment: zod
    .enum(["cross-platform", "platform"])
    .optional()
    .describe("Optional attachment modality of the authenticator."),
  clientExtensionResults: zod
    .object({
      appid: zod
        .boolean()
        .optional()
        .describe('Indicates if the \"appid\" extension was used.'),
      credProps: zod
        .object({
          rk: zod
            .boolean()
            .optional()
            .describe("Indicates if the credential is resident."),
        })
        .optional()
        .describe("Credential properties returned by the client."),
      hmacCreateSecret: zod
        .boolean()
        .optional()
        .describe('Indicates if the \"hmacCreateSecret\" extension was used.'),
    })
    .optional()
    .describe("Optional results of any WebAuthn client extensions."),
});

export const passkeySignUpVerifyMutationFnResponse = zod.object({
  success: zod.literal(true),
  statusCode: zod.literal(201),
  message: zod.string(),
  data: zod.object({
    user: zod
      .object({
        _id: zod.string(),
        name: zod.string(),
        email: zod.string(),
        isEmailVerified: zod.boolean(),
        userPreferences: zod.object({
          enable2FA: zod.boolean(),
          emailNotification: zod.boolean(),
        }),
        createdAt: zod.iso.datetime({}),
        updatedAt: zod.iso.datetime({}),
      })
      .optional(),
    isVerificationEmailSend: zod.boolean().optional(),
    nextStep: zod.enum(["CONFIRM_SIGN_UP"]).optional(),
  }),
  metadata: zod
    .object({
      timestamp: zod.iso
        .datetime({})
        .describe(
          "The exact server-side timestamp when the response was generated."
        ),
      requestId: zod
        .string()
        .describe(
          "A unique identifier for the request, useful for tracing logs and debugging."
        ),
      count: zod
        .number()
        .optional()
        .describe(
          "The total number of items returned in the response (if applicable)."
        ),
    })
    .describe(
      "Contains metadata related to the request and response, such as timestamps, request tracking IDs, and result counts.\n"
    ),
});

/**
 * Completes the **passkey-based sign-in process** by verifying the WebAuthn authentication response 
returned by the browser after calling `navigator.credentials.get()`.  

This endpoint:
  - Validates the cryptographic response (challenge, signature, authenticator data)
  - Ensures the passkey session is still valid and not consumed
  - Confirms that the user exists and is eligible for login
  - Creates a new authenticated session and issues secure access and refresh tokens

On success, the user is authenticated, tokens are issued, and authentication cookies are set.  
If the user's email has not yet been verified, the endpoint returns a pending verification response instead of logging in.

 * @summary Verify a passkey authentication response and complete user login
 */
export const passkeySignInVerifyMutationFnBody = zod
  .object({
    id: zod
      .string()
      .describe(
        "The base64url-encoded credential ID uniquely identifying the passkey credential.\n"
      ),
    rawId: zod
      .string()
      .describe(
        "The raw credential ID in base64url format. Usually identical to `id` but encoded differently.\n"
      ),
    type: zod
      .enum(["public-key"])
      .describe('The credential type. For WebAuthn, always `\"public-key\"`.'),
    authenticatorAttachment: zod
      .enum(["cross-platform", "platform"])
      .optional()
      .describe(
        'Indicates the attachment modality of the authenticator:\n- `\"platform\"`: built into the device (e.g. Touch ID, Windows Hello)\n- `\"cross-platform\"`: external authenticator (e.g. security key)\n'
      ),
    clientExtensionResults: zod
      .object({
        appid: zod
          .boolean()
          .optional()
          .describe("Indicates if the AppID extension was used."),
        credProps: zod
          .object({
            rk: zod
              .boolean()
              .optional()
              .describe("Whether the credential is a resident key."),
          })
          .optional()
          .describe("Credential properties returned by the authenticator."),
        hmacCreateSecret: zod
          .boolean()
          .optional()
          .describe("Indicates if the `hmac-secret` extension was used."),
      })
      .optional()
      .describe(
        "Results from any WebAuthn extensions used during authentication."
      ),
    response: zod
      .object({
        clientDataJSON: zod
          .string()
          .describe(
            "Base64url-encoded JSON object that was passed to the authenticator."
          ),
        authenticatorData: zod
          .string()
          .describe(
            "Base64url-encoded authenticator data containing RP ID hash, flags, and signature counter."
          ),
        signature: zod
          .string()
          .describe(
            "Base64url-encoded signature that proves possession of the private key."
          ),
        userHandle: zod
          .string()
          .describe(
            "Base64url-encoded identifier for the user account associated with the credential."
          ),
      })
      .describe(
        "Contains the raw cryptographic materials returned by the authenticator, required for verifying the authentication response.\n"
      ),
  })
  .describe(
    "Represents the **WebAuthn authentication response** sent by the browser after calling `navigator.credentials.get()` during the passkey sign-in process. This object contains all cryptographic data needed by the backend to verify the authenticity and integrity of the authentication ceremony.\n"
  );

export const passkeySignInVerifyMutationFnResponse = zod.union([
  zod.object({
    success: zod.literal(true),
    statusCode: zod.literal(200),
    message: zod.string(),
    data: zod.object({
      nextStep: zod.enum(["CONFIRM_SIGN_UP"]).optional(),
    }),
    metadata: zod
      .object({
        timestamp: zod.iso
          .datetime({})
          .describe(
            "The exact server-side timestamp when the response was generated."
          ),
        requestId: zod
          .string()
          .describe(
            "A unique identifier for the request, useful for tracing logs and debugging."
          ),
        count: zod
          .number()
          .optional()
          .describe(
            "The total number of items returned in the response (if applicable)."
          ),
      })
      .describe(
        "Contains metadata related to the request and response, such as timestamps, request tracking IDs, and result counts.\n"
      ),
  }),
  zod.object({
    success: zod.literal(true),
    statusCode: zod.literal(200),
    message: zod.string(),
    data: zod.object({
      user: zod.object({
        _id: zod.string(),
        name: zod.string(),
        email: zod.string(),
        isEmailVerified: zod.boolean(),
        userPreferences: zod.object({
          enable2FA: zod.boolean(),
          emailNotification: zod.boolean(),
        }),
        createdAt: zod.iso.datetime({}),
        updatedAt: zod.iso.datetime({}),
      }),
      nextStep: zod.enum(["OK"]),
      mfaRequired: zod.literal(false),
    }),
    metadata: zod
      .object({
        timestamp: zod.iso
          .datetime({})
          .describe(
            "The exact server-side timestamp when the response was generated."
          ),
        requestId: zod
          .string()
          .describe(
            "A unique identifier for the request, useful for tracing logs and debugging."
          ),
        count: zod
          .number()
          .optional()
          .describe(
            "The total number of items returned in the response (if applicable)."
          ),
      })
      .describe(
        "Contains metadata related to the request and response, such as timestamps, request tracking IDs, and result counts.\n"
      ),
  }),
]);

/**
 * Initializes a **WebAuthn passkey registration session** that allows a logged-in user to securely add a new passkey to their account.  

This endpoint performs the following steps:
  1. Validates the authenticated user and checks that they match the `{userid}` path parameter.
  2. Retrieves existing passkeys associated with the account to prevent re-registration of the same authenticator.
  3. Generates a new **WebAuthn PublicKeyCredentialCreationOptions** object (challenge, relying party info, user identity, supported algorithms, etc.).
  4. Persists the challenge session in the database with the `"add-new-key"` purpose for later verification.

The client (frontend) should use the returned `publicKeyOpts` object as input for the `navigator.credentials.create()` call in the browser.

This route requires a valid **access token cookie** for authentication.

 * @summary Initialize a new passkey registration session for an authenticated user
 */
export const passkeyAddPasskeyByUserIdInitMutationFnParams = zod.object({
  userid: zod
    .string()
    .describe(
      "The unique identifier of the user who is adding a new passkey. Must match the currently authenticated user."
    ),
});

/**
 * Completes the registration of a new **Passkey** for the currently authenticated user.  
This endpoint verifies the passkey attestation response generated by the client after initiating the "Add new passkey" process.  

Once verification succeeds:
  - The passkey is securely registered and linked to the user‚Äôs account.
  - The corresponding challenge session is marked as consumed.
  - A success response containing the stored passkey details is returned.

Access to this endpoint requires a valid authenticated session and a matching user ID in the path parameter.

 * @summary Verify and finalize new Passkey registration
 */
export const passkeyAddPasskeyByUserIdVerifyMutationFnParams = zod.object({
  userid: zod
    .string()
    .describe(
      "The unique identifier of the user who is adding a new passkey. Must match the currently authenticated user."
    ),
});

export const passkeyAddPasskeyByUserIdVerifyMutationFnBody = zod.object({
  id: zod
    .string()
    .describe(
      "Base64Url-encoded credential ID generated by the authenticator."
    ),
  rawId: zod.string().describe("Raw Base64Url-encoded credential ID."),
  type: zod.enum(["public-key"]).describe('Must always be \"public-key\".'),
  response: zod.object({
    attestationObject: zod
      .string()
      .describe(
        "Base64Url-encoded attestation object provided by the authenticator."
      ),
    clientDataJSON: zod
      .string()
      .describe("Base64Url-encoded JSON object with client data."),
    authenticatorData: zod
      .string()
      .optional()
      .describe("Optional authenticator data returned by the device."),
    publicKey: zod
      .string()
      .optional()
      .describe("Optional public key generated by the authenticator."),
    publicKeyAlgorithm: zod
      .number()
      .optional()
      .describe("Optional algorithm identifier for the public key."),
    transports: zod
      .array(
        zod.enum([
          "ble",
          "cable",
          "hybrid",
          "internal",
          "nfc",
          "smart-card",
          "usb",
        ])
      )
      .optional()
      .describe("Optional transport methods supported by the authenticator."),
  }),
  authenticatorAttachment: zod
    .enum(["cross-platform", "platform"])
    .optional()
    .describe("Optional attachment modality of the authenticator."),
  clientExtensionResults: zod
    .object({
      appid: zod
        .boolean()
        .optional()
        .describe('Indicates if the \"appid\" extension was used.'),
      credProps: zod
        .object({
          rk: zod
            .boolean()
            .optional()
            .describe("Indicates if the credential is resident."),
        })
        .optional()
        .describe("Credential properties returned by the client."),
      hmacCreateSecret: zod
        .boolean()
        .optional()
        .describe('Indicates if the \"hmacCreateSecret\" extension was used.'),
    })
    .optional()
    .describe("Optional results of any WebAuthn client extensions."),
});

/**
 * This endpoint initiates the process to remove a passkey associated with a user's account.  
The user must be authenticated and authorized to remove a specific passkey, identified by the `credentialid`.  
Upon successful initiation, a passkey removal session is created, and options for the passkey removal request (such as challenge data) are returned.  
The challenge session is created to ensure that the request is authentic, and no unauthorized changes can be made to the passkey list.

**Important:** 
- The user must be authenticated using a valid access token (passed via cookies).
- The `userid` and `credentialid` parameters must match the currently authenticated user and the passkey being removed.

 * @summary Initiate Passkey removal for a user
 */
export const passkeyRemovePasskeyByIdInitMutationFnParams = zod.object({
  userid: zod
    .string()
    .describe(
      "The unique identifier of the user who is removing a passkey.   This must match the authenticated user's ID. Only the user who owns the passkey can initiate the removal.\n"
    ),
  credentialid: zod
    .string()
    .describe(
      "The unique identifier of the passkey credential that is being removed.   This should match the credential ID of the passkey to be deleted.\n"
    ),
});

/**
 * This endpoint allows the authenticated user to remove a specific passkey credential from their account. The request must include the user ID and the credential ID of the passkey to be removed. The user can only remove their own passkeys. This action requires authentication and the provided session must be valid. If successful, the passkey will be permanently deleted from the system, and the session used for verification will be marked as consumed.

 * @summary Remove a passkey credential from a user's account
 */
export const passkeyRemovePasskeyByIdVerifyMutationFnParams = zod.object({
  userid: zod
    .string()
    .describe(
      "The unique identifier of the user who is removing a passkey.   This must match the authenticated user's ID. Only the user who owns the passkey can initiate the removal.\n"
    ),
  credentialid: zod
    .string()
    .describe(
      "The unique identifier of the passkey credential that is being removed.   This should match the credential ID of the passkey to be deleted.\n"
    ),
});

export const passkeyRemovePasskeyByIdVerifyMutationFnBody = zod
  .object({
    id: zod
      .string()
      .describe(
        "The base64url-encoded credential ID uniquely identifying the passkey credential.\n"
      ),
    rawId: zod
      .string()
      .describe(
        "The raw credential ID in base64url format. Usually identical to `id` but encoded differently.\n"
      ),
    type: zod
      .enum(["public-key"])
      .describe('The credential type. For WebAuthn, always `\"public-key\"`.'),
    authenticatorAttachment: zod
      .enum(["cross-platform", "platform"])
      .optional()
      .describe(
        'Indicates the attachment modality of the authenticator:\n- `\"platform\"`: built into the device (e.g. Touch ID, Windows Hello)\n- `\"cross-platform\"`: external authenticator (e.g. security key)\n'
      ),
    clientExtensionResults: zod
      .object({
        appid: zod
          .boolean()
          .optional()
          .describe("Indicates if the AppID extension was used."),
        credProps: zod
          .object({
            rk: zod
              .boolean()
              .optional()
              .describe("Whether the credential is a resident key."),
          })
          .optional()
          .describe("Credential properties returned by the authenticator."),
        hmacCreateSecret: zod
          .boolean()
          .optional()
          .describe("Indicates if the `hmac-secret` extension was used."),
      })
      .optional()
      .describe(
        "Results from any WebAuthn extensions used during authentication."
      ),
    response: zod
      .object({
        clientDataJSON: zod
          .string()
          .describe(
            "Base64url-encoded JSON object that was passed to the authenticator."
          ),
        authenticatorData: zod
          .string()
          .describe(
            "Base64url-encoded authenticator data containing RP ID hash, flags, and signature counter."
          ),
        signature: zod
          .string()
          .describe(
            "Base64url-encoded signature that proves possession of the private key."
          ),
        userHandle: zod
          .string()
          .describe(
            "Base64url-encoded identifier for the user account associated with the credential."
          ),
      })
      .describe(
        "Contains the raw cryptographic materials returned by the authenticator, required for verifying the authentication response.\n"
      ),
  })
  .describe(
    "Represents the **WebAuthn authentication response** sent by the browser after calling `navigator.credentials.get()` during the passkey sign-in process. This object contains all cryptographic data needed by the backend to verify the authenticity and integrity of the authentication ceremony.\n"
  );

/**
 * This endpoint allows you to retrieve all passkeys that are associated with a specific user by their unique `userid`.  The user must be authenticated and the `userid` in the path must match the authenticated user's ID to prevent unauthorized access. Each passkey returned will include essential details such as the credential ID, the associated provider (`aaguid`), the date it was created,  and the last time it was used. The response also includes metadata with the total count of passkeys retrieved.

 * @summary Retrieve all passkeys associated with a user.
 */
export const passkeyAllGetByUserIdQueryFnParams = zod.object({
  userid: zod
    .string()
    .describe(
      "The unique identifier of the user for whom the sessions are being retrieved."
    ),
});

export const passkeyAllGetByUserIdQueryFnResponse = zod.object({
  success: zod
    .boolean()
    .optional()
    .describe("Indicates whether the request was successful."),
  statusCode: zod.number().optional().describe("HTTP status code."),
  message: zod
    .string()
    .optional()
    .describe("A message summarizing the request result."),
  data: zod
    .object({
      passkeys: zod
        .array(
          zod.object({
            aaguid: zod
              .object({
                name: zod
                  .string()
                  .optional()
                  .describe("The name of the passkey provider."),
                icon_dark: zod
                  .string()
                  .optional()
                  .describe("The base64 encoded SVG for the dark theme icon."),
                icon_light: zod
                  .string()
                  .optional()
                  .describe("The base64 encoded SVG for the light theme icon."),
              })
              .optional(),
            credentialId: zod
              .string()
              .optional()
              .describe("The unique identifier of the passkey credential."),
            createdAt: zod.iso
              .datetime({})
              .optional()
              .describe("The date and time when the passkey was created."),
            lastUsed: zod.iso
              .datetime({})
              .optional()
              .describe("The date and time when the passkey was last used."),
          })
        )
        .optional(),
    })
    .optional(),
  metadata: zod
    .object({
      requestId: zod
        .string()
        .optional()
        .describe("A unique identifier for the request."),
      count: zod
        .number()
        .optional()
        .describe("The total number of passkeys retrieved."),
    })
    .optional(),
});
