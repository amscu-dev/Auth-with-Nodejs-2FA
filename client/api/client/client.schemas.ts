/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * API for Password, Passkey, Magic Link, and OIDC Authentication
 * API for user registration and authentication using multiple methods: username/password with capability of 2fa, passkey (WebAuthn), magic link, and OIDC providers (Google, GitHub, etc.).

 * OpenAPI spec version: 1.0.0
 */
export type UserDataUserPreferences = {
  enable2FA: boolean;
  emailNotification: boolean;
};

export interface UserData {
  _id: string;
  name: string;
  email: string;
  isEmailVerified: boolean;
  userPreferences: UserDataUserPreferences;
  createdAt: string;
  updatedAt: string;
}

/**
 * Contains metadata related to the request and response, such as timestamps, request tracking IDs, and result counts.

 */
export interface ResponseMetadata {
  /** The exact server-side timestamp when the response was generated. */
  timestamp: string;
  /** A unique identifier for the request, useful for tracing logs and debugging. */
  requestId: string;
  /** The total number of items returned in the response (if applicable). */
  count?: number;
}

/**
 * Type of WebAuthn credential. Always `"public-key"`.
 */
export type PasskeyDataCredentialType = typeof PasskeyDataCredentialType[keyof typeof PasskeyDataCredentialType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyDataCredentialType = {
  'public-key': 'public-key',
} as const;

export type PasskeyDataTransportsItem = typeof PasskeyDataTransportsItem[keyof typeof PasskeyDataTransportsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyDataTransportsItem = {
  usb: 'usb',
  nfc: 'nfc',
  ble: 'ble',
  internal: 'internal',
  hybrid: 'hybrid',
} as const;

/**
 * Describes the attachment modality of the authenticator.   `"platform"` means a device-integrated authenticator (e.g., Touch ID, Windows Hello).   `"cross-platform"` means an external authenticator (e.g., YubiKey, phone-based passkey).

 */
export type PasskeyDataAuthenticatorAttachment = typeof PasskeyDataAuthenticatorAttachment[keyof typeof PasskeyDataAuthenticatorAttachment];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyDataAuthenticatorAttachment = {
  platform: 'platform',
  'cross-platform': 'cross-platform',
} as const;

/**
 * Information about the authenticator‚Äôs Attestation AAGUID and provider identity.

 */
export type PasskeyDataAaguid = {
  /** Authenticator Attestation GUID uniquely identifying the authenticator model. */
  aaguid?: string;
  /** Human-readable name of the authenticator provider or model. */
  name?: string;
};

/**
 * Represents a registered WebAuthn passkey credential associated with a user account.   Each passkey stores the credential‚Äôs unique identifiers, cryptographic parameters, and metadata about its usage and origin device.

 */
export interface PasskeyData {
  /** Unique identifier of the passkey record in the database. */
  _id: string;
  /** Unique identifier of the user who owns this passkey. */
  userID: string;
  /** Base64URL-encoded credential ID returned by the authenticator. */
  credentialID: string;
  /** Base64-encoded public key associated with the credential used for authentication. */
  credentialPublicKey: string;
  /** Type of WebAuthn credential. Always `"public-key"`. */
  credentialType: PasskeyDataCredentialType;
  /** COSE algorithm identifier used for the credential‚Äôs public key. Common values include `-7` (ES256), `-257` (RS256), or `-8` (EdDSA).
 */
  publicKeyAlgorithm: number;
  /** Monotonically increasing counter maintained by the authenticator to prevent replay attacks. */
  counter: number;
  /** List of supported authenticator transports that can be used to communicate with the credential. Examples include `["usb", "ble", "nfc", "internal"]`.
 */
  transports: PasskeyDataTransportsItem[];
  /** Describes the attachment modality of the authenticator.   `"platform"` means a device-integrated authenticator (e.g., Touch ID, Windows Hello).   `"cross-platform"` means an external authenticator (e.g., YubiKey, phone-based passkey).
 */
  authenticatorAttachment: PasskeyDataAuthenticatorAttachment;
  /** Information about the authenticator‚Äôs Attestation AAGUID and provider identity.
 */
  aaguid: PasskeyDataAaguid;
  /** Timestamp when the passkey was first registered. */
  createdAt: string;
  /** Timestamp of the most recent use of this passkey for authentication. */
  lastUsed?: string;
}

export interface UserRegistrationRequestBody {
  /**
   * The user's full name
   * @minLength 1
   * @maxLength 64
   */
  name: string;
  /**
   * @minLength 1
   * @maxLength 64
   */
  email: string;
  /**
   * Must start with a capital letter and contain at least one special character
   * @minLength 8
   * @pattern ^(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_\-+=\[\]{}|\\;:\'",.<>/?]).{8,}$
   */
  password: string;
  /**
   * Must match the password field
   * @minLength 8
   * @pattern ^(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_\-+=\[\]{}|\\;:\'",.<>/?]).{8,}$
   */
  confirmPassword: string;
}

export interface UserLoginRequestBody {
  /**
   * @minLength 1
   * @maxLength 64
   */
  email: string;
  /**
   * Must start with a capital letter and contain at least one special character
   * @minLength 8
   * @pattern ^(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_\-+=\[\]{}|\\;:\'",.<>/?]).{8,}$
   */
  password: string;
}

export interface ForgotPasswordRequestBody {
  email: string;
}

export interface ResetPasswordRequestBody {
  /**
   * @minLength 1
   * @maxLength 64
   */
  verificationCode: string;
  /**
   * Must start with a capital letter and contain at least one special character
   * @minLength 8
   * @pattern ^(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_\-+=\[\]{}|\\;:\'",.<>/?]).{8,}$
   */
  password: string;
}

export interface MagicLinkSignUpRequestBody {
  /**
   * The user's full name
   * @minLength 1
   * @maxLength 64
   */
  name: string;
  /**
   * @minLength 1
   * @maxLength 64
   */
  email: string;
}

export interface MagicLinkSignInRequestBody {
  /**
   * @minLength 1
   * @maxLength 64
   */
  email: string;
}

/**
 * Must always be "public-key".
 */
export type PasskeyCompletRegistrationRequestBodyType = typeof PasskeyCompletRegistrationRequestBodyType[keyof typeof PasskeyCompletRegistrationRequestBodyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyCompletRegistrationRequestBodyType = {
  'public-key': 'public-key',
} as const;

export type PasskeyCompletRegistrationRequestBodyResponseTransportsItem = typeof PasskeyCompletRegistrationRequestBodyResponseTransportsItem[keyof typeof PasskeyCompletRegistrationRequestBodyResponseTransportsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyCompletRegistrationRequestBodyResponseTransportsItem = {
  ble: 'ble',
  cable: 'cable',
  hybrid: 'hybrid',
  internal: 'internal',
  nfc: 'nfc',
  'smart-card': 'smart-card',
  usb: 'usb',
} as const;

export type PasskeyCompletRegistrationRequestBodyResponse = {
  /** Base64Url-encoded attestation object provided by the authenticator. */
  attestationObject: string;
  /** Base64Url-encoded JSON object with client data. */
  clientDataJSON: string;
  /** Optional authenticator data returned by the device. */
  authenticatorData?: string;
  /** Optional public key generated by the authenticator. */
  publicKey?: string;
  /** Optional algorithm identifier for the public key. */
  publicKeyAlgorithm?: number;
  /** Optional transport methods supported by the authenticator. */
  transports?: PasskeyCompletRegistrationRequestBodyResponseTransportsItem[];
};

/**
 * Optional attachment modality of the authenticator.
 */
export type PasskeyCompletRegistrationRequestBodyAuthenticatorAttachment = typeof PasskeyCompletRegistrationRequestBodyAuthenticatorAttachment[keyof typeof PasskeyCompletRegistrationRequestBodyAuthenticatorAttachment];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyCompletRegistrationRequestBodyAuthenticatorAttachment = {
  'cross-platform': 'cross-platform',
  platform: 'platform',
} as const;

/**
 * Credential properties returned by the client.
 */
export type PasskeyCompletRegistrationRequestBodyClientExtensionResultsCredProps = {
  /** Indicates if the credential is resident. */
  rk?: boolean;
};

/**
 * Optional results of any WebAuthn client extensions.
 */
export type PasskeyCompletRegistrationRequestBodyClientExtensionResults = {
  /** Indicates if the "appid" extension was used. */
  appid?: boolean;
  /** Credential properties returned by the client. */
  credProps?: PasskeyCompletRegistrationRequestBodyClientExtensionResultsCredProps;
  /** Indicates if the "hmacCreateSecret" extension was used. */
  hmacCreateSecret?: boolean;
};

export interface PasskeyCompletRegistrationRequestBody {
  /** Base64Url-encoded credential ID generated by the authenticator. */
  id: string;
  /** Raw Base64Url-encoded credential ID. */
  rawId: string;
  /** Must always be "public-key". */
  type: PasskeyCompletRegistrationRequestBodyType;
  response: PasskeyCompletRegistrationRequestBodyResponse;
  /** Optional attachment modality of the authenticator. */
  authenticatorAttachment?: PasskeyCompletRegistrationRequestBodyAuthenticatorAttachment;
  /** Optional results of any WebAuthn client extensions. */
  clientExtensionResults?: PasskeyCompletRegistrationRequestBodyClientExtensionResults;
}

/**
 * The credential type. For WebAuthn, always `"public-key"`.
 */
export type PasskeyCompletAuthenticationRequestBodyType = typeof PasskeyCompletAuthenticationRequestBodyType[keyof typeof PasskeyCompletAuthenticationRequestBodyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyCompletAuthenticationRequestBodyType = {
  'public-key': 'public-key',
} as const;

/**
 * Indicates the attachment modality of the authenticator:
- `"platform"`: built into the device (e.g. Touch ID, Windows Hello)
- `"cross-platform"`: external authenticator (e.g. security key)

 */
export type PasskeyCompletAuthenticationRequestBodyAuthenticatorAttachment = typeof PasskeyCompletAuthenticationRequestBodyAuthenticatorAttachment[keyof typeof PasskeyCompletAuthenticationRequestBodyAuthenticatorAttachment];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyCompletAuthenticationRequestBodyAuthenticatorAttachment = {
  'cross-platform': 'cross-platform',
  platform: 'platform',
} as const;

/**
 * Credential properties returned by the authenticator.
 */
export type PasskeyCompletAuthenticationRequestBodyClientExtensionResultsCredProps = {
  /** Whether the credential is a resident key. */
  rk?: boolean;
};

/**
 * Results from any WebAuthn extensions used during authentication.
 */
export type PasskeyCompletAuthenticationRequestBodyClientExtensionResults = {
  /** Indicates if the AppID extension was used. */
  appid?: boolean;
  /** Credential properties returned by the authenticator. */
  credProps?: PasskeyCompletAuthenticationRequestBodyClientExtensionResultsCredProps;
  /** Indicates if the `hmac-secret` extension was used. */
  hmacCreateSecret?: boolean;
};

/**
 * Contains the raw cryptographic materials returned by the authenticator, required for verifying the authentication response.

 */
export type PasskeyCompletAuthenticationRequestBodyResponse = {
  /** Base64url-encoded JSON object that was passed to the authenticator. */
  clientDataJSON: string;
  /** Base64url-encoded authenticator data containing RP ID hash, flags, and signature counter. */
  authenticatorData: string;
  /** Base64url-encoded signature that proves possession of the private key. */
  signature: string;
  /** Base64url-encoded identifier for the user account associated with the credential. */
  userHandle: string;
};

/**
 * Represents the **WebAuthn authentication response** sent by the browser after calling `navigator.credentials.get()` during the passkey sign-in process. This object contains all cryptographic data needed by the backend to verify the authenticity and integrity of the authentication ceremony.

 */
export interface PasskeyCompletAuthenticationRequestBody {
  /** The base64url-encoded credential ID uniquely identifying the passkey credential.
 */
  id: string;
  /** The raw credential ID in base64url format. Usually identical to `id` but encoded differently.
 */
  rawId: string;
  /** The credential type. For WebAuthn, always `"public-key"`. */
  type: PasskeyCompletAuthenticationRequestBodyType;
  /** Indicates the attachment modality of the authenticator:
- `"platform"`: built into the device (e.g. Touch ID, Windows Hello)
- `"cross-platform"`: external authenticator (e.g. security key)
 */
  authenticatorAttachment?: PasskeyCompletAuthenticationRequestBodyAuthenticatorAttachment;
  /** Results from any WebAuthn extensions used during authentication. */
  clientExtensionResults?: PasskeyCompletAuthenticationRequestBodyClientExtensionResults;
  /** Contains the raw cryptographic materials returned by the authenticator, required for verifying the authentication response.
 */
  response: PasskeyCompletAuthenticationRequestBodyResponse;
}

export type RegistrationSuccessReponseStatusCode = typeof RegistrationSuccessReponseStatusCode[keyof typeof RegistrationSuccessReponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RegistrationSuccessReponseStatusCode = {
  NUMBER_201: 201,
} as const;

export type RegistrationSuccessReponseDataNextStep = typeof RegistrationSuccessReponseDataNextStep[keyof typeof RegistrationSuccessReponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RegistrationSuccessReponseDataNextStep = {
  CONFIRM_SIGN_UP: 'CONFIRM_SIGN_UP',
} as const;

export type RegistrationSuccessReponseData = {
  user?: UserData;
  isVerificationEmailSend?: boolean;
  nextStep?: RegistrationSuccessReponseDataNextStep;
};

export interface RegistrationSuccessReponse {
  success: boolean;
  statusCode: RegistrationSuccessReponseStatusCode;
  message: string;
  data: RegistrationSuccessReponseData;
  metadata: ResponseMetadata;
}

export type LoginEmailVerificationPendingResponseStatusCode = typeof LoginEmailVerificationPendingResponseStatusCode[keyof typeof LoginEmailVerificationPendingResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LoginEmailVerificationPendingResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type LoginEmailVerificationPendingResponseDataNextStep = typeof LoginEmailVerificationPendingResponseDataNextStep[keyof typeof LoginEmailVerificationPendingResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LoginEmailVerificationPendingResponseDataNextStep = {
  CONFIRM_SIGN_UP: 'CONFIRM_SIGN_UP',
} as const;

export type LoginEmailVerificationPendingResponseData = {
  nextStep?: LoginEmailVerificationPendingResponseDataNextStep;
};

export interface LoginEmailVerificationPendingResponse {
  success: boolean;
  statusCode: LoginEmailVerificationPendingResponseStatusCode;
  message: string;
  data: LoginEmailVerificationPendingResponseData;
  metadata: ResponseMetadata;
}

export type LoginSuccessResponseStatusCode = typeof LoginSuccessResponseStatusCode[keyof typeof LoginSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LoginSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type LoginSuccessResponseDataNextStep = typeof LoginSuccessResponseDataNextStep[keyof typeof LoginSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LoginSuccessResponseDataNextStep = {
  OK: 'OK',
} as const;

export type LoginSuccessResponseData = {
  user: UserData;
  nextStep: LoginSuccessResponseDataNextStep;
  mfaRequired: boolean;
};

export interface LoginSuccessResponse {
  success: boolean;
  statusCode: LoginSuccessResponseStatusCode;
  message: string;
  data: LoginSuccessResponseData;
  metadata: ResponseMetadata;
}

export type MFAPendingResponseStatusCode = typeof MFAPendingResponseStatusCode[keyof typeof MFAPendingResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFAPendingResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type MFAPendingResponseDataNextStep = typeof MFAPendingResponseDataNextStep[keyof typeof MFAPendingResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFAPendingResponseDataNextStep = {
  MFA_REQUIRED: 'MFA_REQUIRED',
} as const;

export type MFAPendingResponseData = {
  nextStep: MFAPendingResponseDataNextStep;
  mfaRequired: boolean;
};

export interface MFAPendingResponse {
  success: boolean;
  statusCode: MFAPendingResponseStatusCode;
  message: string;
  data: MFAPendingResponseData;
  metadata: ResponseMetadata;
}

export type EmailConfirmedSuccessResponseStatusCode = typeof EmailConfirmedSuccessResponseStatusCode[keyof typeof EmailConfirmedSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmailConfirmedSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type EmailConfirmedSuccessResponseDataNextStep = typeof EmailConfirmedSuccessResponseDataNextStep[keyof typeof EmailConfirmedSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmailConfirmedSuccessResponseDataNextStep = {
  CONFIRMED_EMAIL_RETURN_TO_LOGIN: 'CONFIRMED_EMAIL_RETURN_TO_LOGIN',
} as const;

export type EmailConfirmedSuccessResponseData = {
  nextStep: EmailConfirmedSuccessResponseDataNextStep;
};

export interface EmailConfirmedSuccessResponse {
  success: boolean;
  statusCode: EmailConfirmedSuccessResponseStatusCode;
  message: string;
  data: EmailConfirmedSuccessResponseData;
  metadata: ResponseMetadata;
}

export type ForgotPasswordSuccessResponseStatusCode = typeof ForgotPasswordSuccessResponseStatusCode[keyof typeof ForgotPasswordSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ForgotPasswordSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type ForgotPasswordSuccessResponseDataNextStep = typeof ForgotPasswordSuccessResponseDataNextStep[keyof typeof ForgotPasswordSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ForgotPasswordSuccessResponseDataNextStep = {
  OK: 'OK',
} as const;

export type ForgotPasswordSuccessResponseData = {
  nextStep: ForgotPasswordSuccessResponseDataNextStep;
  mfaRequired: boolean;
};

export interface ForgotPasswordSuccessResponse {
  success: boolean;
  statusCode: ForgotPasswordSuccessResponseStatusCode;
  message: string;
  data: ForgotPasswordSuccessResponseData;
  metadata: ResponseMetadata;
}

export type ResetPasswordSuccessResponseStatusCode = typeof ResetPasswordSuccessResponseStatusCode[keyof typeof ResetPasswordSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResetPasswordSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type ResetPasswordSuccessResponseDataNextStep = typeof ResetPasswordSuccessResponseDataNextStep[keyof typeof ResetPasswordSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResetPasswordSuccessResponseDataNextStep = {
  OK: 'OK',
} as const;

export type ResetPasswordSuccessResponseData = {
  nextStep: ResetPasswordSuccessResponseDataNextStep;
};

export interface ResetPasswordSuccessResponse {
  success: boolean;
  statusCode: ResetPasswordSuccessResponseStatusCode;
  message: string;
  data: ResetPasswordSuccessResponseData;
  metadata: ResponseMetadata;
}

export type RefreshTokenEndpointSuccessResponseStatusCode = typeof RefreshTokenEndpointSuccessResponseStatusCode[keyof typeof RefreshTokenEndpointSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RefreshTokenEndpointSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type RefreshTokenEndpointSuccessResponseDataNextStep = typeof RefreshTokenEndpointSuccessResponseDataNextStep[keyof typeof RefreshTokenEndpointSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RefreshTokenEndpointSuccessResponseDataNextStep = {
  OK: 'OK',
} as const;

export type RefreshTokenEndpointSuccessResponseData = {
  nextStep: RefreshTokenEndpointSuccessResponseDataNextStep;
};

export interface RefreshTokenEndpointSuccessResponse {
  success: boolean;
  statusCode: RefreshTokenEndpointSuccessResponseStatusCode;
  message: string;
  data: RefreshTokenEndpointSuccessResponseData;
  metadata: ResponseMetadata;
}

export type LogoutSuccessResponseStatusCode = typeof LogoutSuccessResponseStatusCode[keyof typeof LogoutSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LogoutSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type LogoutSuccessResponseDataNextStep = typeof LogoutSuccessResponseDataNextStep[keyof typeof LogoutSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LogoutSuccessResponseDataNextStep = {
  LOGOUT: 'LOGOUT',
} as const;

export type LogoutSuccessResponseData = {
  nextStep: LogoutSuccessResponseDataNextStep;
};

export interface LogoutSuccessResponse {
  success: boolean;
  statusCode: LogoutSuccessResponseStatusCode;
  message: string;
  data: LogoutSuccessResponseData;
  metadata: ResponseMetadata;
}

export type MagicLinkSignUpSuccessResponseStatusCode = typeof MagicLinkSignUpSuccessResponseStatusCode[keyof typeof MagicLinkSignUpSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MagicLinkSignUpSuccessResponseStatusCode = {
  NUMBER_201: 201,
} as const;

export type MagicLinkSignUpSuccessResponseDataNextStep = typeof MagicLinkSignUpSuccessResponseDataNextStep[keyof typeof MagicLinkSignUpSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MagicLinkSignUpSuccessResponseDataNextStep = {
  CHECK_EMAIL_FOR_MAGIC_LINK: 'CHECK_EMAIL_FOR_MAGIC_LINK',
} as const;

export type MagicLinkSignUpSuccessResponseData = {
  user?: UserData;
  isMagicLinkEmailSend?: boolean;
  nextStep?: MagicLinkSignUpSuccessResponseDataNextStep;
};

export interface MagicLinkSignUpSuccessResponse {
  success: boolean;
  statusCode: MagicLinkSignUpSuccessResponseStatusCode;
  message: string;
  data: MagicLinkSignUpSuccessResponseData;
  metadata: ResponseMetadata;
}

export type MagicLinkSignInSuccessResponseStatusCode = typeof MagicLinkSignInSuccessResponseStatusCode[keyof typeof MagicLinkSignInSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MagicLinkSignInSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type MagicLinkSignInSuccessResponseDataNextStep = typeof MagicLinkSignInSuccessResponseDataNextStep[keyof typeof MagicLinkSignInSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MagicLinkSignInSuccessResponseDataNextStep = {
  CHECK_EMAIL_FOR_MAGIC_LINK: 'CHECK_EMAIL_FOR_MAGIC_LINK',
} as const;

export type MagicLinkSignInSuccessResponseData = {
  isMagicLinkEmailSend?: boolean;
  nextStep?: MagicLinkSignInSuccessResponseDataNextStep;
};

export interface MagicLinkSignInSuccessResponse {
  success: boolean;
  statusCode: MagicLinkSignInSuccessResponseStatusCode;
  message: string;
  data: MagicLinkSignInSuccessResponseData;
  metadata: ResponseMetadata;
}

export type MfaSetupResponseStatusCode = typeof MfaSetupResponseStatusCode[keyof typeof MfaSetupResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MfaSetupResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type MfaSetupResponseData = {
  /**
   * Base32-encoded TOTP secret for the user. This secret is used to generate OTP codes.
   * @pattern ^[A-Z2-7]+=*$
   */
  secret: string;
  /** Base64-encoded PNG image of the QR code for TOTP setup. Can be rendered in clients as an image. */
  qrImageUrl: string;
};

export interface MfaSetupResponse {
  success: boolean;
  statusCode: MfaSetupResponseStatusCode;
  message: string;
  data: MfaSetupResponseData;
  metadata: ResponseMetadata;
}

export type MFAVerifySetupSuccessResponseStatusCode = typeof MFAVerifySetupSuccessResponseStatusCode[keyof typeof MFAVerifySetupSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFAVerifySetupSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type MFAVerifySetupSuccessResponseDataUserPreferences = {
  enable2FA?: boolean;
  backupCodes: string[];
};

export type MFAVerifySetupSuccessResponseData = {
  userPreferences: MFAVerifySetupSuccessResponseDataUserPreferences;
};

export interface MFAVerifySetupSuccessResponse {
  success: boolean;
  statusCode: MFAVerifySetupSuccessResponseStatusCode;
  message: string;
  data: MFAVerifySetupSuccessResponseData;
  metadata: ResponseMetadata;
}

export type MFARevokeSuccessReponseStatusCode = typeof MFARevokeSuccessReponseStatusCode[keyof typeof MFARevokeSuccessReponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFARevokeSuccessReponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type MFARevokeSuccessReponseData = {
  user?: UserData;
};

export interface MFARevokeSuccessReponse {
  success: boolean;
  statusCode: MFARevokeSuccessReponseStatusCode;
  message: string;
  data: MFARevokeSuccessReponseData;
  metadata: ResponseMetadata;
}

export type MFARequestChangePasswordSuccessReponseStatusCode = typeof MFARequestChangePasswordSuccessReponseStatusCode[keyof typeof MFARequestChangePasswordSuccessReponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFARequestChangePasswordSuccessReponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type MFARequestChangePasswordSuccessReponseDataNextStep = typeof MFARequestChangePasswordSuccessReponseDataNextStep[keyof typeof MFARequestChangePasswordSuccessReponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFARequestChangePasswordSuccessReponseDataNextStep = {
  OK: 'OK',
} as const;

export type MFARequestChangePasswordSuccessReponseData = {
  nextStep: MFARequestChangePasswordSuccessReponseDataNextStep;
};

export interface MFARequestChangePasswordSuccessReponse {
  success: boolean;
  statusCode: MFARequestChangePasswordSuccessReponseStatusCode;
  message: string;
  data: MFARequestChangePasswordSuccessReponseData;
  metadata: ResponseMetadata;
}

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsRp = {
  /** The display name of the application (Relying Party).  This is shown to the user during registration/authentication.
 */
  name?: string;
  /** The unique identifier of the Relying Party, usually the domain name.  Used by the browser to validate the registration request and prevent phishing.
 */
  id?: string;
};

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsUser = {
  /** Base64 or URL-safe encoded user ID */
  id?: string;
  name?: string;
  displayName?: string;
};

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsPubKeyCredParamsItem = {
  alg: number;
  type: string;
};

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAttestation = typeof PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAttestation[keyof typeof PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAttestation];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAttestation = {
  direct: 'direct',
} as const;

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsExcludeCredentialsItem = { [key: string]: unknown };

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionResidentKey = typeof PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionResidentKey[keyof typeof PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionResidentKey];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionResidentKey = {
  required: 'required',
} as const;

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionUserVerification = typeof PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionUserVerification[keyof typeof PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionUserVerification];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionUserVerification = {
  required: 'required',
} as const;

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelection = {
  residentKey?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionResidentKey;
  requireResidentKey?: boolean;
  userVerification?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionUserVerification;
};

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsExtensions = {
  credProps?: boolean;
};

/**
 * WebAuthn options to complete the passkey registration on the client side.
 */
export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOpts = {
  /** Base64-encoded challenge for WebAuthn registration. */
  challenge?: string;
  rp?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsRp;
  user?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsUser;
  /** The cryptographic algorithms supported by the relying party for the public-key credential.  Each object specifies the algorithm (`alg`) and type (`type`).  These algorithms correspond to the COSE algorithm identifiers:
  -7: ES256 (ECDSA w/ SHA-256)
  -8: EdDSA (Ed25519)
  -257: RS256 (RSASSA-PKCS1-v1_5 w/ SHA-256)
 */
  pubKeyCredParams?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsPubKeyCredParamsItem[];
  /** Timeout for the operation in milliseconds */
  timeout?: number;
  attestation?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAttestation;
  excludeCredentials?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsExcludeCredentialsItem[];
  authenticatorSelection?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelection;
  extensions?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsExtensions;
  hints?: string[];
};

export type PasskeyGenerateSignUpSessionSuccessResponseData = {
  /** WebAuthn options to complete the passkey registration on the client side. */
  publicKeyOpts?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOpts;
};

export interface PasskeyGenerateSignUpSessionSuccessResponse {
  /** HTTP status code of the response. */
  statusCode?: number;
  /** Indicates that the request was successful. */
  success?: boolean;
  /** Human-readable message describing the response. */
  message?: string;
  data?: PasskeyGenerateSignUpSessionSuccessResponseData;
  metadata?: ResponseMetadata;
}

export type PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType = typeof PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType[keyof typeof PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType = {
  'public-key': 'public-key',
} as const;

export type PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem = typeof PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem[keyof typeof PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem = {
  ble: 'ble',
  cable: 'cable',
  hybrid: 'hybrid',
  internal: 'internal',
  nfc: 'nfc',
  'smart-card': 'smart-card',
  usb: 'usb',
} as const;

export type PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItem = {
  /** Base64URL-encoded identifier of the allowed credential. */
  id?: string;
  type?: PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType;
  /** Optional list of transports supported by this credential. */
  transports?: PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem[];
};

/**
 * Indicates whether the authenticator must perform user verification.
 */
export type PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification = typeof PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification[keyof typeof PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification = {
  required: 'required',
  preferred: 'preferred',
  discouraged: 'discouraged',
} as const;

/**
 * Options provided to the client for completing the WebAuthn authentication ceremony.
 */
export type PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptions = {
  /** The relying party identifier, usually the domain name of your web application. */
  rpId: string;
  /** A unique cryptographic challenge generated by the server to prevent replay attacks. */
  challenge: string;
  /** A list of previously registered credentials that are allowed for authentication.  
If empty, the authenticator may select any credential associated with the user.
 */
  allowCredentials: PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItem[];
  /** The time, in milliseconds, that the client is allowed to take to complete the authentication. */
  timeout: number;
  /** Indicates whether the authenticator must perform user verification. */
  userVerification: PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification;
};

/**
 * Contains the created public key credential request options used by the client to proceed with WebAuthn authentication.
 */
export type PasskeyGenerateSignInSessionSuccessResponseData = {
  /** Options provided to the client for completing the WebAuthn authentication ceremony. */
  publicKeyCredentialRequestOptions?: PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptions;
};

/**
 * Response returned when a new passkey authentication session has been successfully created.
 */
export interface PasskeyGenerateSignInSessionSuccessResponse {
  /** HTTP status code indicating that the passkey session was successfully created. */
  statusCode: number;
  /** Indicates whether the operation was successful. */
  success: boolean;
  /** A human-readable message describing the result of the operation. */
  message: string;
  /** Contains the created public key credential request options used by the client to proceed with WebAuthn authentication. */
  data: PasskeyGenerateSignInSessionSuccessResponseData;
  metadata: ResponseMetadata;
}

export type PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType = typeof PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType[keyof typeof PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType = {
  'public-key': 'public-key',
} as const;

export type PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem = typeof PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem[keyof typeof PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem = {
  ble: 'ble',
  cable: 'cable',
  hybrid: 'hybrid',
  internal: 'internal',
  nfc: 'nfc',
  'smart-card': 'smart-card',
  usb: 'usb',
} as const;

export type PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItem = {
  /** Base64URL-encoded identifier of the allowed credential. */
  id?: string;
  type?: PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType;
  /** Optional list of transports supported by this credential. */
  transports?: PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem[];
};

/**
 * Indicates whether the authenticator must perform user verification.
 */
export type PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification = typeof PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification[keyof typeof PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification = {
  required: 'required',
  preferred: 'preferred',
  discouraged: 'discouraged',
} as const;

/**
 * Options provided to the client for completing the WebAuthn authentication ceremony.
 */
export type PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptions = {
  /** The relying party identifier, usually the domain name of your web application. */
  rpId: string;
  /** A unique cryptographic challenge generated by the server to prevent replay attacks. */
  challenge: string;
  /** A list of previously registered credentials that are allowed for authentication.  
If empty, the authenticator may select any credential associated with the user.
 */
  allowCredentials: PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItem[];
  /** The time, in milliseconds, that the client is allowed to take to complete the authentication. */
  timeout: number;
  /** Indicates whether the authenticator must perform user verification. */
  userVerification: PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification;
};

/**
 * Contains the created public key credential request options used by the client to proceed with WebAuthn authentication.
 */
export type PasskeyGenerateRemoveKeySuccessResponseData = {
  /** Options provided to the client for completing the WebAuthn authentication ceremony. */
  publicKeyCredentialRequestOptions?: PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptions;
};

/**
 * Response returned when a new passkey authentication session has been successfully created.
 */
export interface PasskeyGenerateRemoveKeySuccessResponse {
  /** HTTP status code indicating that the passkey session was successfully created. */
  statusCode: number;
  /** Indicates whether the operation was successful. */
  success: boolean;
  /** A human-readable message describing the result of the operation. */
  message: string;
  /** Contains the created public key credential request options used by the client to proceed with WebAuthn authentication. */
  data: PasskeyGenerateRemoveKeySuccessResponseData;
  metadata: ResponseMetadata;
}

/**
 * Contains the newly added passkey details.
 */
export type PasskeyAddedSuccessResponseData = {
  passkey?: PasskeyData;
};

/**
 * Response returned when a new passkey has been successfully registered and added to the user account.

 */
export interface PasskeyAddedSuccessResponse {
  /** Indicates whether the operation was successful. */
  success: boolean;
  /** HTTP status code associated with this response. */
  statusCode: number;
  /** Human-readable message describing the result of the operation. */
  message: string;
  /** Contains the newly added passkey details. */
  data: PasskeyAddedSuccessResponseData;
  metadata: ResponseMetadata;
}

export type PasskeyRemovedSuccessResponseData = { [key: string]: unknown };

/**
 * Response returned when a new passkey has been successfully registered and added to the user account.

 */
export interface PasskeyRemovedSuccessResponse {
  /** Indicates whether the operation was successful. */
  success: boolean;
  /** HTTP status code associated with this response. */
  statusCode: number;
  /** Human-readable message describing the result of the operation. */
  message: string;
  data: PasskeyRemovedSuccessResponseData;
  metadata: ResponseMetadata;
}

export type PasskeyGetAllPasskeyByUserIdSuccessResponseDataPasskeysItemAaguid = {
  /** The name of the passkey provider. */
  name?: string;
  /** The base64 encoded SVG for the dark theme icon. */
  icon_dark?: string;
  /** The base64 encoded SVG for the light theme icon. */
  icon_light?: string;
};

export type PasskeyGetAllPasskeyByUserIdSuccessResponseDataPasskeysItem = {
  aaguid?: PasskeyGetAllPasskeyByUserIdSuccessResponseDataPasskeysItemAaguid;
  /** The unique identifier of the passkey credential. */
  credentialId?: string;
  /** The date and time when the passkey was created. */
  createdAt?: string;
  /** The date and time when the passkey was last used. */
  lastUsed?: string;
};

export type PasskeyGetAllPasskeyByUserIdSuccessResponseData = {
  passkeys?: PasskeyGetAllPasskeyByUserIdSuccessResponseDataPasskeysItem[];
};

export type PasskeyGetAllPasskeyByUserIdSuccessResponseMetadata = {
  /** A unique identifier for the request. */
  requestId?: string;
  /** The total number of passkeys retrieved. */
  count?: number;
};

export interface PasskeyGetAllPasskeyByUserIdSuccessResponse {
  /** Indicates whether the request was successful. */
  success?: boolean;
  /** HTTP status code. */
  statusCode?: number;
  /** A message summarizing the request result. */
  message?: string;
  data?: PasskeyGetAllPasskeyByUserIdSuccessResponseData;
  metadata?: PasskeyGetAllPasskeyByUserIdSuccessResponseMetadata;
}

export type GetAllSessionsSuccessResponseDataSessionsItemUserAgent = {
  browser?: string;
  version?: string;
  os?: string;
  platform?: string;
};

export type GetAllSessionsSuccessResponseDataSessionsItem = {
  /** Unique identifier of the session. */
  _id?: string;
  /** Unique identifier of the user who owns the session. */
  userId?: string;
  userAgent?: GetAllSessionsSuccessResponseDataSessionsItemUserAgent;
  /** The expiration date and time of the session. */
  expiredAt?: string;
  /** The creation date and time of the session. */
  createdAt?: string;
  /** Indicates if this is the current session. */
  isCurrent?: boolean;
};

export type GetAllSessionsSuccessResponseData = {
  sessions?: GetAllSessionsSuccessResponseDataSessionsItem[];
};

export interface GetAllSessionsSuccessResponse {
  /** Indicates whether the operation was successful */
  success?: boolean;
  /** HTTP status code of the response */
  statusCode?: number;
  message?: string;
  data?: GetAllSessionsSuccessResponseData;
  metadata?: ResponseMetadata;
}

export type GetCurrentSessionSuccessResponseData = {
  user?: UserData;
};

export interface GetCurrentSessionSuccessResponse {
  /** Indicates whether the operation was successful */
  success: boolean;
  /** HTTP status code of the response */
  statusCode: number;
  message: string;
  data: GetCurrentSessionSuccessResponseData;
  metadata: ResponseMetadata;
}

export type DeleteSessionByIdSuccessResponseData = {
  /** If the deleted session was the current session, indicates the next action for the client (e.g., LOGIN.LOGOUT).
 */
  nextStep?: string;
};

export interface DeleteSessionByIdSuccessResponse {
  /** Indicates whether the operation was successful */
  success: boolean;
  /** HTTP status code of the response */
  statusCode: number;
  /** A human-readable message describing the result */
  message: string;
  data: DeleteSessionByIdSuccessResponseData;
  metadata: ResponseMetadata;
}

export type GetOIDCAuthUrlSuccessResponseData = {
  /** URL that is used to call OIDC provider. */
  url: string;
};

export interface GetOIDCAuthUrlSuccessResponse {
  /** Indicates whether the operation was successful */
  success: boolean;
  /** HTTP status code of the response */
  statusCode: number;
  message: string;
  data: GetOIDCAuthUrlSuccessResponseData;
  metadata?: ResponseMetadata;
}

export type EmailResendSuccessResponseData = {
  /** User email address. */
  email: string;
  /** Boolean value validating if mail was successfully send to user. */
  isEmailSuccessfullySend: boolean;
};

export interface EmailResendSuccessResponse {
  /** Indicates whether the operation was successful */
  success: boolean;
  /** HTTP status code of the response */
  statusCode: number;
  message: string;
  data: EmailResendSuccessResponseData;
  metadata?: ResponseMetadata;
}

export type EmailCheckSuccessResponseData = {
  /** User email address. */
  email: string;
  /** Boolean value validating if email address is not registered in database. */
  isNewEmail: boolean;
};

export interface EmailCheckSuccessResponse {
  /** Indicates whether the operation was successful */
  success: boolean;
  /** HTTP status code of the response */
  statusCode: number;
  message: string;
  data: EmailCheckSuccessResponseData;
  metadata?: ResponseMetadata;
}

export type InternalServerErrorErrorCode = typeof InternalServerErrorErrorCode[keyof typeof InternalServerErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InternalServerErrorErrorCode = {
  INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
} as const;

export interface InternalServerError {
  success: boolean;
  message: string;
  errorCode: InternalServerErrorErrorCode;
  requestId: string;
}

export type ForbiddenErrorErrorCode = typeof ForbiddenErrorErrorCode[keyof typeof ForbiddenErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ForbiddenErrorErrorCode = {
  ACCESS_FORBIDDEN: 'ACCESS_FORBIDDEN',
} as const;

export interface ForbiddenError {
  success: boolean;
  message: string;
  errorCode: ForbiddenErrorErrorCode;
  requestId: string;
}

export type TooManyRequestsErrorErrorCode = typeof TooManyRequestsErrorErrorCode[keyof typeof TooManyRequestsErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TooManyRequestsErrorErrorCode = {
  TOO_MANY_REQUESTS: 'TOO_MANY_REQUESTS',
} as const;

export interface TooManyRequestsError {
  success: boolean;
  message: string;
  errorCode: TooManyRequestsErrorErrorCode;
  requestId: string;
}

export type EmailServiceErrorErrorCode = typeof EmailServiceErrorErrorCode[keyof typeof EmailServiceErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmailServiceErrorErrorCode = {
  EMAIL_SERVICE_ERROR: 'EMAIL_SERVICE_ERROR',
} as const;

export interface EmailServiceError {
  success: boolean;
  message: string;
  errorCode: EmailServiceErrorErrorCode;
  requestId: string;
}

export type InvalidRequestBodyValidationErrorErrorCode = typeof InvalidRequestBodyValidationErrorErrorCode[keyof typeof InvalidRequestBodyValidationErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvalidRequestBodyValidationErrorErrorCode = {
  VALIDATION_ERROR_INVALID_REQUEST_BODY: 'VALIDATION_ERROR_INVALID_REQUEST_BODY',
} as const;

export type InvalidRequestBodyValidationErrorErrorsItem = {
  field: string;
  message: string;
};

export interface InvalidRequestBodyValidationError {
  success: boolean;
  message: string;
  errorCode: InvalidRequestBodyValidationErrorErrorCode;
  requestId: string;
  /** @minItems 1 */
  errors: InvalidRequestBodyValidationErrorErrorsItem[];
}

export type EmailAlreadyExistsErrorErrorCode = typeof EmailAlreadyExistsErrorErrorCode[keyof typeof EmailAlreadyExistsErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmailAlreadyExistsErrorErrorCode = {
  AUTH_EMAIL_ALREADY_EXISTS: 'AUTH_EMAIL_ALREADY_EXISTS',
} as const;

export interface EmailAlreadyExistsError {
  success: boolean;
  message: string;
  errorCode: EmailAlreadyExistsErrorErrorCode;
  requestId: string;
}

export type UserNotFoundErrorErrorCode = typeof UserNotFoundErrorErrorCode[keyof typeof UserNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserNotFoundErrorErrorCode = {
  AUTH_USER_NOT_FOUND: 'AUTH_USER_NOT_FOUND',
} as const;

export interface UserNotFoundError {
  success: boolean;
  message: string;
  errorCode: UserNotFoundErrorErrorCode;
  requestId: string;
}

export type EmailNotFoundErrorErrorCode = typeof EmailNotFoundErrorErrorCode[keyof typeof EmailNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmailNotFoundErrorErrorCode = {
  AUTH_EMAIL_NOT_FOUND: 'AUTH_EMAIL_NOT_FOUND',
} as const;

export interface EmailNotFoundError {
  success: boolean;
  message: string;
  errorCode: EmailNotFoundErrorErrorCode;
  requestId: string;
}

export type EmailAlreadyVerifiedErrorErrorCode = typeof EmailAlreadyVerifiedErrorErrorCode[keyof typeof EmailAlreadyVerifiedErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmailAlreadyVerifiedErrorErrorCode = {
  AUTH_EMAIL_NOT_FOUND: 'AUTH_EMAIL_NOT_FOUND',
} as const;

export interface EmailAlreadyVerifiedError {
  success: boolean;
  message: string;
  errorCode: EmailAlreadyVerifiedErrorErrorCode;
  requestId: string;
}

export type InvalidCredentialsErrorErrorCode = typeof InvalidCredentialsErrorErrorCode[keyof typeof InvalidCredentialsErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvalidCredentialsErrorErrorCode = {
  AUTH_INVALID_CREDENTIALS: 'AUTH_INVALID_CREDENTIALS',
} as const;

export interface InvalidCredentialsError {
  success: boolean;
  message: string;
  errorCode: InvalidCredentialsErrorErrorCode;
  requestId: string;
}

export type PasswordReuseNotAllowedErrorCode = typeof PasswordReuseNotAllowedErrorCode[keyof typeof PasswordReuseNotAllowedErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasswordReuseNotAllowedErrorCode = {
  AUTH_PASSWORD_REUSE_NOT_ALLOWED: 'AUTH_PASSWORD_REUSE_NOT_ALLOWED',
} as const;

export interface PasswordReuseNotAllowed {
  success: boolean;
  message: string;
  errorCode: PasswordReuseNotAllowedErrorCode;
  requestId: string;
}

export type VerificationCodeNotFoundErrorErrorCode = typeof VerificationCodeNotFoundErrorErrorCode[keyof typeof VerificationCodeNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VerificationCodeNotFoundErrorErrorCode = {
  VERIFICATION_CODE_ERROR_CODE_NOT_FOUND: 'VERIFICATION_CODE_ERROR_CODE_NOT_FOUND',
} as const;

export interface VerificationCodeNotFoundError {
  success: boolean;
  message: string;
  errorCode: VerificationCodeNotFoundErrorErrorCode;
  requestId: string;
}

export type VerificationCodeExpiredErrorErrorCode = typeof VerificationCodeExpiredErrorErrorCode[keyof typeof VerificationCodeExpiredErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VerificationCodeExpiredErrorErrorCode = {
  VERIFICATION_CODE_ERROR_CODE_EXPIRED: 'VERIFICATION_CODE_ERROR_CODE_EXPIRED',
} as const;

export interface VerificationCodeExpiredError {
  success: boolean;
  message: string;
  errorCode: VerificationCodeExpiredErrorErrorCode;
  requestId: string;
}

export type VerificationCodeConsumedErrorErrorCode = typeof VerificationCodeConsumedErrorErrorCode[keyof typeof VerificationCodeConsumedErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VerificationCodeConsumedErrorErrorCode = {
  VERIFICATION_CODE_ERROR_CODE_CONSUMED: 'VERIFICATION_CODE_ERROR_CODE_CONSUMED',
} as const;

export interface VerificationCodeConsumedError {
  success: boolean;
  message: string;
  errorCode: VerificationCodeConsumedErrorErrorCode;
  requestId: string;
}

export type AuthenticationTokenNotFoundErrorErrorCode = typeof AuthenticationTokenNotFoundErrorErrorCode[keyof typeof AuthenticationTokenNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationTokenNotFoundErrorErrorCode = {
  AUTH_TOKEN_NOT_FOUND: 'AUTH_TOKEN_NOT_FOUND',
} as const;

export interface AuthenticationTokenNotFoundError {
  success: boolean;
  message: string;
  errorCode: AuthenticationTokenNotFoundErrorErrorCode;
  requestId: string;
}

export type AuthenticationTokenUserNotFoundErrorErrorCode = typeof AuthenticationTokenUserNotFoundErrorErrorCode[keyof typeof AuthenticationTokenUserNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationTokenUserNotFoundErrorErrorCode = {
  AUTH_TOKEN_USER_NOT_FOUND: 'AUTH_TOKEN_USER_NOT_FOUND',
} as const;

export interface AuthenticationTokenUserNotFoundError {
  success: boolean;
  message: string;
  errorCode: AuthenticationTokenUserNotFoundErrorErrorCode;
  requestId: string;
}

export type AuthenticationTokenInvalidSessionErrorErrorCode = typeof AuthenticationTokenInvalidSessionErrorErrorCode[keyof typeof AuthenticationTokenInvalidSessionErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationTokenInvalidSessionErrorErrorCode = {
  AUTH_TOKEN_SESSION_INVALID: 'AUTH_TOKEN_SESSION_INVALID',
} as const;

export interface AuthenticationTokenInvalidSessionError {
  success: boolean;
  message: string;
  errorCode: AuthenticationTokenInvalidSessionErrorErrorCode;
  requestId: string;
}

export type AuthenticationTokenSessionMismatchErrorErrorCode = typeof AuthenticationTokenSessionMismatchErrorErrorCode[keyof typeof AuthenticationTokenSessionMismatchErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationTokenSessionMismatchErrorErrorCode = {
  AUTH_TOKEN_SESSION_MISMATCH: 'AUTH_TOKEN_SESSION_MISMATCH',
} as const;

export interface AuthenticationTokenSessionMismatchError {
  success: boolean;
  message: string;
  errorCode: AuthenticationTokenSessionMismatchErrorErrorCode;
  requestId: string;
}

export type AuthenticationTokenInvalidTokenErorrErrorCode = typeof AuthenticationTokenInvalidTokenErorrErrorCode[keyof typeof AuthenticationTokenInvalidTokenErorrErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationTokenInvalidTokenErorrErrorCode = {
  AUTH_TOKEN_INVALID: 'AUTH_TOKEN_INVALID',
} as const;

export interface AuthenticationTokenInvalidTokenErorr {
  success: boolean;
  message: string;
  errorCode: AuthenticationTokenInvalidTokenErorrErrorCode;
  requestId: string;
}

export type AuthenticationTokenExpiredErrorErrorCode = typeof AuthenticationTokenExpiredErrorErrorCode[keyof typeof AuthenticationTokenExpiredErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationTokenExpiredErrorErrorCode = {
  AUTH_TOKEN_EXPIRED: 'AUTH_TOKEN_EXPIRED',
} as const;

export interface AuthenticationTokenExpiredError {
  success: boolean;
  message: string;
  errorCode: AuthenticationTokenExpiredErrorErrorCode;
  requestId: string;
}

export type AccessTokenTypeErrorErrorCode = typeof AccessTokenTypeErrorErrorCode[keyof typeof AccessTokenTypeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccessTokenTypeErrorErrorCode = {
  AUTH_ACCESS_TOKEN_TYPE_INVALID: 'AUTH_ACCESS_TOKEN_TYPE_INVALID',
} as const;

export interface AccessTokenTypeError {
  success: boolean;
  message: string;
  errorCode: AccessTokenTypeErrorErrorCode;
  requestId: string;
}

export type MFATokenTypeErrorErrorCode = typeof MFATokenTypeErrorErrorCode[keyof typeof MFATokenTypeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFATokenTypeErrorErrorCode = {
  AUTH_MFA_TOKEN_TYPE_INVALID: 'AUTH_MFA_TOKEN_TYPE_INVALID',
} as const;

export interface MFATokenTypeError {
  success: boolean;
  message: string;
  errorCode: MFATokenTypeErrorErrorCode;
  requestId: string;
}

export type MFATokenInvalidEndpointErrorErrorCode = typeof MFATokenInvalidEndpointErrorErrorCode[keyof typeof MFATokenInvalidEndpointErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFATokenInvalidEndpointErrorErrorCode = {
  AUTH_MFA_INVALID_ENDPOINT: 'AUTH_MFA_INVALID_ENDPOINT',
} as const;

export interface MFATokenInvalidEndpointError {
  success: boolean;
  message: string;
  errorCode: MFATokenInvalidEndpointErrorErrorCode;
  requestId: string;
}

export type MFATokenInvalidTokenPurposeErrorErrorCode = typeof MFATokenInvalidTokenPurposeErrorErrorCode[keyof typeof MFATokenInvalidTokenPurposeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFATokenInvalidTokenPurposeErrorErrorCode = {
  AUTH_TOKEN_INVALID_TYPE: 'AUTH_TOKEN_INVALID_TYPE',
} as const;

export interface MFATokenInvalidTokenPurposeError {
  success: boolean;
  message: string;
  errorCode: MFATokenInvalidTokenPurposeErrorErrorCode;
  requestId: string;
}

export type MFAForbiddenErrorErrorCode = typeof MFAForbiddenErrorErrorCode[keyof typeof MFAForbiddenErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFAForbiddenErrorErrorCode = {
  ACCESS_FORBIDDEN: 'ACCESS_FORBIDDEN',
} as const;

export interface MFAForbiddenError {
  success: boolean;
  message: string;
  errorCode: MFAForbiddenErrorErrorCode;
  requestId: string;
}

export type MagicLinkTokenTypeErrorErrorCode = typeof MagicLinkTokenTypeErrorErrorCode[keyof typeof MagicLinkTokenTypeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MagicLinkTokenTypeErrorErrorCode = {
  AUTH_MAGIC_LINK_TOKEN_TYPE_INVALID: 'AUTH_MAGIC_LINK_TOKEN_TYPE_INVALID',
} as const;

export interface MagicLinkTokenTypeError {
  success: boolean;
  message: string;
  errorCode: MagicLinkTokenTypeErrorErrorCode;
  requestId: string;
}

export type RefreshTokenTypeErrorErrorCode = typeof RefreshTokenTypeErrorErrorCode[keyof typeof RefreshTokenTypeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RefreshTokenTypeErrorErrorCode = {
  AUTH_REFRESH_TOKEN_TYPE_INVALID: 'AUTH_REFRESH_TOKEN_TYPE_INVALID',
} as const;

export interface RefreshTokenTypeError {
  success: boolean;
  message: string;
  errorCode: RefreshTokenTypeErrorErrorCode;
  requestId: string;
}

export type RefreshTokenInvalidSessionErrorErrorCode = typeof RefreshTokenInvalidSessionErrorErrorCode[keyof typeof RefreshTokenInvalidSessionErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RefreshTokenInvalidSessionErrorErrorCode = {
  AUTH_REFRESH_TOKEN_SESSION_INVALID: 'AUTH_REFRESH_TOKEN_SESSION_INVALID',
} as const;

export interface RefreshTokenInvalidSessionError {
  success: boolean;
  message: string;
  errorCode: RefreshTokenInvalidSessionErrorErrorCode;
  requestId: string;
}

export type RefreshTokenExpiredSessionErrorErrorCode = typeof RefreshTokenExpiredSessionErrorErrorCode[keyof typeof RefreshTokenExpiredSessionErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RefreshTokenExpiredSessionErrorErrorCode = {
  AUTH_REFRESH_TOKEN_SESSION_EXPIRED: 'AUTH_REFRESH_TOKEN_SESSION_EXPIRED',
} as const;

export interface RefreshTokenExpiredSessionError {
  success: boolean;
  message: string;
  errorCode: RefreshTokenExpiredSessionErrorErrorCode;
  requestId: string;
}

export type MfaAlreadyEnabledErrorErrorCode = typeof MfaAlreadyEnabledErrorErrorCode[keyof typeof MfaAlreadyEnabledErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MfaAlreadyEnabledErrorErrorCode = {
  MFA_ALREADY_ENABLED: 'MFA_ALREADY_ENABLED',
} as const;

export interface MfaAlreadyEnabledError {
  success: boolean;
  message: string;
  errorCode: MfaAlreadyEnabledErrorErrorCode;
  requestId: string;
}

export type MfaAlreadyDisabledErrorErrorCode = typeof MfaAlreadyDisabledErrorErrorCode[keyof typeof MfaAlreadyDisabledErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MfaAlreadyDisabledErrorErrorCode = {
  MFA_ALREADY_DISABLED: 'MFA_ALREADY_DISABLED',
} as const;

export interface MfaAlreadyDisabledError {
  success: boolean;
  message: string;
  errorCode: MfaAlreadyDisabledErrorErrorCode;
  requestId: string;
}

export type MfaTemporarySecretExpiredErrorErrorCode = typeof MfaTemporarySecretExpiredErrorErrorCode[keyof typeof MfaTemporarySecretExpiredErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MfaTemporarySecretExpiredErrorErrorCode = {
  MFA_EXPIRED_TEMP_SECRET: 'MFA_EXPIRED_TEMP_SECRET',
} as const;

export interface MfaTemporarySecretExpiredError {
  success: boolean;
  message: string;
  errorCode: MfaTemporarySecretExpiredErrorErrorCode;
  requestId: string;
}

export type MfaInvalidVerificationCodeErrorErrorCode = typeof MfaInvalidVerificationCodeErrorErrorCode[keyof typeof MfaInvalidVerificationCodeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MfaInvalidVerificationCodeErrorErrorCode = {
  MFA_INVALID_VERIFICATION_CODE: 'MFA_INVALID_VERIFICATION_CODE',
} as const;

export interface MfaInvalidVerificationCodeError {
  success: boolean;
  message: string;
  errorCode: MfaInvalidVerificationCodeErrorErrorCode;
  requestId: string;
}

export type MfaNotEnabledErrorErrorCode = typeof MfaNotEnabledErrorErrorCode[keyof typeof MfaNotEnabledErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MfaNotEnabledErrorErrorCode = {
  MFA_NOT_ENABLED: 'MFA_NOT_ENABLED',
} as const;

export interface MfaNotEnabledError {
  success: boolean;
  message: string;
  errorCode: MfaNotEnabledErrorErrorCode;
  requestId: string;
}

export type InvalidBackupCodeErrorErrorCode = typeof InvalidBackupCodeErrorErrorCode[keyof typeof InvalidBackupCodeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvalidBackupCodeErrorErrorCode = {
  BACKUPCODE_INVALID_CODE: 'BACKUPCODE_INVALID_CODE',
} as const;

export interface InvalidBackupCodeError {
  success: boolean;
  message: string;
  errorCode: InvalidBackupCodeErrorErrorCode;
  requestId: string;
}

export type OIDCSessionNotFoundErrorErrorCode = typeof OIDCSessionNotFoundErrorErrorCode[keyof typeof OIDCSessionNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OIDCSessionNotFoundErrorErrorCode = {
  OIDC_SESSION_NOT_FOUND: 'OIDC_SESSION_NOT_FOUND',
} as const;

export interface OIDCSessionNotFoundError {
  success: boolean;
  message: string;
  errorCode: OIDCSessionNotFoundErrorErrorCode;
  requestId: string;
}

export type OIDCSessionExpiredErrorErrorCode = typeof OIDCSessionExpiredErrorErrorCode[keyof typeof OIDCSessionExpiredErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OIDCSessionExpiredErrorErrorCode = {
  OIDC_SESSION_CONSUMED: 'OIDC_SESSION_CONSUMED',
} as const;

export interface OIDCSessionExpiredError {
  success: boolean;
  message: string;
  errorCode: OIDCSessionExpiredErrorErrorCode;
  requestId: string;
}

export type OIDCSessionConsumedErrorErrorCode = typeof OIDCSessionConsumedErrorErrorCode[keyof typeof OIDCSessionConsumedErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OIDCSessionConsumedErrorErrorCode = {
  OIDC_SESSION_CONSUMED: 'OIDC_SESSION_CONSUMED',
} as const;

export interface OIDCSessionConsumedError {
  success: boolean;
  message: string;
  errorCode: OIDCSessionConsumedErrorErrorCode;
  requestId: string;
}

export type OIDCFailedAuthenticationErrorErrorCode = typeof OIDCFailedAuthenticationErrorErrorCode[keyof typeof OIDCFailedAuthenticationErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OIDCFailedAuthenticationErrorErrorCode = {
  OIDC_FAILED_AUTHENTIFICATION: 'OIDC_FAILED_AUTHENTIFICATION',
} as const;

export interface OIDCFailedAuthenticationError {
  success: boolean;
  message: string;
  errorCode: OIDCFailedAuthenticationErrorErrorCode;
  requestId: string;
}

export type PasskeyChallengeSessionNotFoundErrorErrorCode = typeof PasskeyChallengeSessionNotFoundErrorErrorCode[keyof typeof PasskeyChallengeSessionNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyChallengeSessionNotFoundErrorErrorCode = {
  PASSKEY_CHALLENGE_SESSION_INVALID: 'PASSKEY_CHALLENGE_SESSION_INVALID',
} as const;

export interface PasskeyChallengeSessionNotFoundError {
  success: boolean;
  message: string;
  errorCode: PasskeyChallengeSessionNotFoundErrorErrorCode;
  requestId: string;
}

export type PasskeyChallengeSessionConsumedErrorErrorCode = typeof PasskeyChallengeSessionConsumedErrorErrorCode[keyof typeof PasskeyChallengeSessionConsumedErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyChallengeSessionConsumedErrorErrorCode = {
  PASSKEY_CHALLENGE_SESSION_CONSUMED: 'PASSKEY_CHALLENGE_SESSION_CONSUMED',
} as const;

export interface PasskeyChallengeSessionConsumedError {
  success: boolean;
  message: string;
  errorCode: PasskeyChallengeSessionConsumedErrorErrorCode;
  requestId: string;
}

export type PasskeyChallengeSessionInvalidPurposeErrorErrorCode = typeof PasskeyChallengeSessionInvalidPurposeErrorErrorCode[keyof typeof PasskeyChallengeSessionInvalidPurposeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyChallengeSessionInvalidPurposeErrorErrorCode = {
  PASSKEY_CHALLENGE_SESSION__INVALID_PURPOSE: 'PASSKEY_CHALLENGE_SESSION__INVALID_PURPOSE',
} as const;

export interface PasskeyChallengeSessionInvalidPurposeError {
  success: boolean;
  message: string;
  errorCode: PasskeyChallengeSessionInvalidPurposeErrorErrorCode;
  requestId: string;
}

export type PasskeyChallengeSessionExpiredErrorErrorCode = typeof PasskeyChallengeSessionExpiredErrorErrorCode[keyof typeof PasskeyChallengeSessionExpiredErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyChallengeSessionExpiredErrorErrorCode = {
  PASSKEY_CHALLENGE_SESSION__EXPIRED: 'PASSKEY_CHALLENGE_SESSION__EXPIRED',
} as const;

export interface PasskeyChallengeSessionExpiredError {
  success: boolean;
  message: string;
  errorCode: PasskeyChallengeSessionExpiredErrorErrorCode;
  requestId: string;
}

export type PasskeyChallengeVerificationErrorErrorCode = typeof PasskeyChallengeVerificationErrorErrorCode[keyof typeof PasskeyChallengeVerificationErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyChallengeVerificationErrorErrorCode = {
  PASSKEY_CHALENGE_VERIFICATION_ERROR: 'PASSKEY_CHALENGE_VERIFICATION_ERROR',
} as const;

export interface PasskeyChallengeVerificationError {
  success: boolean;
  message: string;
  errorCode: PasskeyChallengeVerificationErrorErrorCode;
  requestId: string;
}

export type PasskeyNotFoundErrorErrorCode = typeof PasskeyNotFoundErrorErrorCode[keyof typeof PasskeyNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyNotFoundErrorErrorCode = {
  PASSKEY_NOT_FOUND: 'PASSKEY_NOT_FOUND',
} as const;

export interface PasskeyNotFoundError {
  success: boolean;
  message: string;
  errorCode: PasskeyNotFoundErrorErrorCode;
  requestId: string;
}

export type UserSessionNotFoundErrorErrorCode = typeof UserSessionNotFoundErrorErrorCode[keyof typeof UserSessionNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSessionNotFoundErrorErrorCode = {
  AUTH_SESSION_NOT_FOUND: 'AUTH_SESSION_NOT_FOUND',
} as const;

export interface UserSessionNotFoundError {
  success: boolean;
  message: string;
  errorCode: UserSessionNotFoundErrorErrorCode;
  requestId: string;
}

export type InvalidAccessJwtTokenResponse = AuthenticationTokenNotFoundError | AccessTokenTypeError | AuthenticationTokenUserNotFoundError | AuthenticationTokenInvalidSessionError | AuthenticationTokenSessionMismatchError | AuthenticationTokenInvalidTokenErorr | AuthenticationTokenExpiredError;

export type InvalidMFAJwtTokenResponse = AuthenticationTokenNotFoundError | MFATokenTypeError | MFATokenInvalidEndpointError | MFATokenInvalidTokenPurposeError | AuthenticationTokenUserNotFoundError | AuthenticationTokenInvalidSessionError | AuthenticationTokenSessionMismatchError | AuthenticationTokenInvalidTokenErorr | AuthenticationTokenExpiredError;

export type InvalidMagicLinkJwtTokenResponse = AuthenticationTokenNotFoundError | MagicLinkTokenTypeError | AuthenticationTokenUserNotFoundError | AuthenticationTokenInvalidSessionError | AuthenticationTokenSessionMismatchError | AuthenticationTokenInvalidTokenErorr | AuthenticationTokenExpiredError;

export type InvalidRefreshJwtTokenResponse = RefreshTokenInvalidSessionError | AuthenticationTokenNotFoundError | RefreshTokenTypeError | AuthenticationTokenUserNotFoundError | RefreshTokenExpiredSessionError | AuthenticationTokenSessionMismatchError | AuthenticationTokenInvalidTokenErorr | AuthenticationTokenExpiredError;

export type AuthSignUpMutationFn400 = EmailAlreadyExistsError | InvalidRequestBodyValidationError;

export type AuthSignInMutationFn200 = LoginEmailVerificationPendingResponse | MFAPendingResponse | LoginSuccessResponse;

export type AuthPasswordForgotMutationFn200 = MFAPendingResponse | ForgotPasswordSuccessResponse;

export type AuthPasswordResetMutationFn400 = VerificationCodeExpiredError | VerificationCodeConsumedError | PasswordReuseNotAllowed;

export type AuthPasswordResetMutationFn404 = VerificationCodeNotFoundError | UserNotFoundError;

export type AuthResendEmailMutationFnBody = {
  email: string;
};

export type AuthCheckEmailMutationFnBody = {
  email: string;
};

export type AuthEmailVerifyMutationFnBody = {
  code: string;
};

export type AuthEmailVerifyMutationFn400 = VerificationCodeExpiredError | VerificationCodeConsumedError;

export type MfaVerifyMutationFnBody = {
  /** The 6-digit one-time password (OTP) generated by the user's authenticator app or received via the selected MFA method.
 */
  code: string;
};

export type MfaVerifyMutationFn400 = MfaTemporarySecretExpiredError | MfaInvalidVerificationCodeError;

export type MfaRevokeMutationFnBody = {
  /** The 6-digit one-time password (OTP) generated by the user's authenticator app.   Must be valid at the time of request.
 */
  code: string;
};

export type MfaBackupCodeConsumeMutationFnBody = {
  /** The valid unused backup code associated with the user's account. */
  backupCode: string;
};

export type MfaBackupCodeLoginMutationFnBody = {
  /** The valid unused backup code associated with the user's account. */
  backupCode: string;
};

export type MfaVerifyLoginMutationFnBody = {
  /** The 6-digit one-time password (OTP) generated by the user's authenticator app.   Must be valid at the time of request.
 */
  code: string;
};

export type MfaVerifyLoginMutationFn400 = MfaNotEnabledError | MfaInvalidVerificationCodeError;

export type MfaVerifyForgotPasswordMutationFnBody = {
  /** The 6-digit one-time password (OTP) generated by the user's authenticator app.   Must be valid at the time of request.
 */
  code: string;
};

export type MfaVerifyForgotPasswordMutationFn400 = MfaNotEnabledError | MfaInvalidVerificationCodeError;

export type PasskeySignUpInitMutationFnBody = {
  /** The display name of the user registering a passkey. */
  name: string;
  /** The email address of the user registering a passkey. */
  email: string;
};

export type PasskeySignUpVerifyMutationFn401 = PasskeyChallengeSessionNotFoundError | PasskeyChallengeSessionExpiredError | PasskeyChallengeVerificationError;

export type PasskeySignInVerifyMutationFn200 = LoginEmailVerificationPendingResponse | LoginSuccessResponse;

export type PasskeySignInVerifyMutationFn401 = PasskeyChallengeSessionNotFoundError | PasskeyChallengeSessionExpiredError | PasskeyChallengeVerificationError | PasskeyNotFoundError;

export type PasskeyAddPasskeyByUserIdVerifyMutationFn401 = PasskeyChallengeSessionNotFoundError | PasskeyChallengeSessionExpiredError | PasskeyChallengeVerificationError | PasskeyNotFoundError | AuthenticationTokenNotFoundError | AccessTokenTypeError | AuthenticationTokenUserNotFoundError | AuthenticationTokenInvalidSessionError | AuthenticationTokenSessionMismatchError | AuthenticationTokenInvalidTokenErorr | AuthenticationTokenExpiredError;

export type PasskeyRemovePasskeyByIdVerifyMutationFn401 = PasskeyChallengeSessionNotFoundError | PasskeyChallengeSessionExpiredError | PasskeyChallengeVerificationError | AuthenticationTokenNotFoundError | AccessTokenTypeError | AuthenticationTokenUserNotFoundError | AuthenticationTokenInvalidSessionError | AuthenticationTokenSessionMismatchError | AuthenticationTokenInvalidTokenErorr | AuthenticationTokenExpiredError;

export type OidcGoogleCallbackGetQueryFnParams = {
/**
 * Authorization code returned by Google
 */
code: string;
/**
 * Unique state generated during the authorization request
 */
state: string;
};

export type OidcGoogleCallbackGetQueryFn400 = OIDCSessionExpiredError | OIDCSessionConsumedError;

export type OidcGithubCallbackGetQueryFnParams = {
/**
 * Authorization code returned by Github
 */
code: string;
/**
 * Unique state generated during the authorization request
 */
state: string;
};

export type OidcGithubCallbackGetQueryFn400 = OIDCSessionExpiredError | OIDCSessionConsumedError;

