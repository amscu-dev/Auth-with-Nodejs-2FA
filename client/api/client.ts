/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * API for Password, Passkey, Magic Link, and OIDC Authentication
 * API for user registration and authentication using multiple methods: username/password with capability of 2fa, passkey (WebAuthn), magic link, and OIDC providers (Google, GitHub, etc.).

 * OpenAPI spec version: 1.0.0
 */
import axios from 'axios';
import type {
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

export type UserDataUserPreferences = {
  enable2FA: boolean;
  emailNotification: boolean;
};

export interface UserData {
  _id: string;
  name: string;
  email: string;
  isEmailVerified: boolean;
  userPreferences: UserDataUserPreferences;
  createdAt: string;
  updatedAt: string;
}

/**
 * Contains metadata related to the request and response, such as timestamps, request tracking IDs, and result counts.

 */
export interface ResponseMetadata {
  /** The exact server-side timestamp when the response was generated. */
  timestamp: string;
  /** A unique identifier for the request, useful for tracing logs and debugging. */
  requestId: string;
  /** The total number of items returned in the response (if applicable). */
  count?: number;
}

/**
 * Type of WebAuthn credential. Always `"public-key"`.
 */
export type PasskeyDataCredentialType = typeof PasskeyDataCredentialType[keyof typeof PasskeyDataCredentialType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyDataCredentialType = {
  'public-key': 'public-key',
} as const;

export type PasskeyDataTransportsItem = typeof PasskeyDataTransportsItem[keyof typeof PasskeyDataTransportsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyDataTransportsItem = {
  usb: 'usb',
  nfc: 'nfc',
  ble: 'ble',
  internal: 'internal',
  hybrid: 'hybrid',
} as const;

/**
 * Describes the attachment modality of the authenticator.   `"platform"` means a device-integrated authenticator (e.g., Touch ID, Windows Hello).   `"cross-platform"` means an external authenticator (e.g., YubiKey, phone-based passkey).

 */
export type PasskeyDataAuthenticatorAttachment = typeof PasskeyDataAuthenticatorAttachment[keyof typeof PasskeyDataAuthenticatorAttachment];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyDataAuthenticatorAttachment = {
  platform: 'platform',
  'cross-platform': 'cross-platform',
} as const;

/**
 * Information about the authenticator‚Äôs Attestation AAGUID and provider identity.

 */
export type PasskeyDataAaguid = {
  /** Authenticator Attestation GUID uniquely identifying the authenticator model. */
  aaguid?: string;
  /** Human-readable name of the authenticator provider or model. */
  name?: string;
};

/**
 * Represents a registered WebAuthn passkey credential associated with a user account.   Each passkey stores the credential‚Äôs unique identifiers, cryptographic parameters, and metadata about its usage and origin device.

 */
export interface PasskeyData {
  /** Unique identifier of the passkey record in the database. */
  _id: string;
  /** Unique identifier of the user who owns this passkey. */
  userID: string;
  /** Base64URL-encoded credential ID returned by the authenticator. */
  credentialID: string;
  /** Base64-encoded public key associated with the credential used for authentication. */
  credentialPublicKey: string;
  /** Type of WebAuthn credential. Always `"public-key"`. */
  credentialType: PasskeyDataCredentialType;
  /** COSE algorithm identifier used for the credential‚Äôs public key. Common values include `-7` (ES256), `-257` (RS256), or `-8` (EdDSA).
 */
  publicKeyAlgorithm: number;
  /** Monotonically increasing counter maintained by the authenticator to prevent replay attacks. */
  counter: number;
  /** List of supported authenticator transports that can be used to communicate with the credential. Examples include `["usb", "ble", "nfc", "internal"]`.
 */
  transports: PasskeyDataTransportsItem[];
  /** Describes the attachment modality of the authenticator.   `"platform"` means a device-integrated authenticator (e.g., Touch ID, Windows Hello).   `"cross-platform"` means an external authenticator (e.g., YubiKey, phone-based passkey).
 */
  authenticatorAttachment: PasskeyDataAuthenticatorAttachment;
  /** Information about the authenticator‚Äôs Attestation AAGUID and provider identity.
 */
  aaguid: PasskeyDataAaguid;
  /** Timestamp when the passkey was first registered. */
  createdAt: string;
  /** Timestamp of the most recent use of this passkey for authentication. */
  lastUsed?: string;
}

export interface UserRegistrationRequestBody {
  /**
   * The user's full name
   * @minLength 1
   * @maxLength 64
   */
  name: string;
  /**
   * @minLength 1
   * @maxLength 64
   */
  email: string;
  /**
   * Must start with a capital letter and contain at least one special character
   * @minLength 8
   * @pattern ^(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_\-+=\[\]{}|\\;:\'",.<>/?]).{8,}$
   */
  password: string;
  /**
   * Must match the password field
   * @minLength 8
   * @pattern ^(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_\-+=\[\]{}|\\;:\'",.<>/?]).{8,}$
   */
  confirmPassword: string;
}

export interface UserLoginRequestBody {
  /**
   * @minLength 1
   * @maxLength 64
   */
  email: string;
  /**
   * Must start with a capital letter and contain at least one special character
   * @minLength 8
   * @pattern ^(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_\-+=\[\]{}|\\;:\'",.<>/?]).{8,}$
   */
  password: string;
}

export interface ForgotPasswordRequestBody {
  email: string;
}

export interface ResetPasswordRequestBody {
  /**
   * @minLength 1
   * @maxLength 64
   */
  verificationCode: string;
  /**
   * Must start with a capital letter and contain at least one special character
   * @minLength 8
   * @pattern ^(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_\-+=\[\]{}|\\;:\'",.<>/?]).{8,}$
   */
  password: string;
}

export interface MagicLinkSignUpRequestBody {
  /**
   * The user's full name
   * @minLength 1
   * @maxLength 64
   */
  name: string;
  /**
   * @minLength 1
   * @maxLength 64
   */
  email: string;
}

export interface MagicLinkSignInRequestBody {
  /**
   * @minLength 1
   * @maxLength 64
   */
  email: string;
}

/**
 * Must always be "public-key".
 */
export type PasskeyCompletRegistrationRequestBodyType = typeof PasskeyCompletRegistrationRequestBodyType[keyof typeof PasskeyCompletRegistrationRequestBodyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyCompletRegistrationRequestBodyType = {
  'public-key': 'public-key',
} as const;

export type PasskeyCompletRegistrationRequestBodyResponseTransportsItem = typeof PasskeyCompletRegistrationRequestBodyResponseTransportsItem[keyof typeof PasskeyCompletRegistrationRequestBodyResponseTransportsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyCompletRegistrationRequestBodyResponseTransportsItem = {
  ble: 'ble',
  cable: 'cable',
  hybrid: 'hybrid',
  internal: 'internal',
  nfc: 'nfc',
  'smart-card': 'smart-card',
  usb: 'usb',
} as const;

export type PasskeyCompletRegistrationRequestBodyResponse = {
  /** Base64Url-encoded attestation object provided by the authenticator. */
  attestationObject: string;
  /** Base64Url-encoded JSON object with client data. */
  clientDataJSON: string;
  /** Optional authenticator data returned by the device. */
  authenticatorData?: string;
  /** Optional public key generated by the authenticator. */
  publicKey?: string;
  /** Optional algorithm identifier for the public key. */
  publicKeyAlgorithm?: number;
  /** Optional transport methods supported by the authenticator. */
  transports?: PasskeyCompletRegistrationRequestBodyResponseTransportsItem[];
};

/**
 * Optional attachment modality of the authenticator.
 */
export type PasskeyCompletRegistrationRequestBodyAuthenticatorAttachment = typeof PasskeyCompletRegistrationRequestBodyAuthenticatorAttachment[keyof typeof PasskeyCompletRegistrationRequestBodyAuthenticatorAttachment];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyCompletRegistrationRequestBodyAuthenticatorAttachment = {
  'cross-platform': 'cross-platform',
  platform: 'platform',
} as const;

/**
 * Credential properties returned by the client.
 */
export type PasskeyCompletRegistrationRequestBodyClientExtensionResultsCredProps = {
  /** Indicates if the credential is resident. */
  rk?: boolean;
};

/**
 * Optional results of any WebAuthn client extensions.
 */
export type PasskeyCompletRegistrationRequestBodyClientExtensionResults = {
  /** Indicates if the "appid" extension was used. */
  appid?: boolean;
  /** Credential properties returned by the client. */
  credProps?: PasskeyCompletRegistrationRequestBodyClientExtensionResultsCredProps;
  /** Indicates if the "hmacCreateSecret" extension was used. */
  hmacCreateSecret?: boolean;
};

export interface PasskeyCompletRegistrationRequestBody {
  /** Base64Url-encoded credential ID generated by the authenticator. */
  id: string;
  /** Raw Base64Url-encoded credential ID. */
  rawId: string;
  /** Must always be "public-key". */
  type: PasskeyCompletRegistrationRequestBodyType;
  response: PasskeyCompletRegistrationRequestBodyResponse;
  /** Optional attachment modality of the authenticator. */
  authenticatorAttachment?: PasskeyCompletRegistrationRequestBodyAuthenticatorAttachment;
  /** Optional results of any WebAuthn client extensions. */
  clientExtensionResults?: PasskeyCompletRegistrationRequestBodyClientExtensionResults;
}

/**
 * The credential type. For WebAuthn, always `"public-key"`.
 */
export type PasskeyCompletAuthenticationRequestBodyType = typeof PasskeyCompletAuthenticationRequestBodyType[keyof typeof PasskeyCompletAuthenticationRequestBodyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyCompletAuthenticationRequestBodyType = {
  'public-key': 'public-key',
} as const;

/**
 * Indicates the attachment modality of the authenticator:
- `"platform"`: built into the device (e.g. Touch ID, Windows Hello)
- `"cross-platform"`: external authenticator (e.g. security key)

 */
export type PasskeyCompletAuthenticationRequestBodyAuthenticatorAttachment = typeof PasskeyCompletAuthenticationRequestBodyAuthenticatorAttachment[keyof typeof PasskeyCompletAuthenticationRequestBodyAuthenticatorAttachment];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyCompletAuthenticationRequestBodyAuthenticatorAttachment = {
  'cross-platform': 'cross-platform',
  platform: 'platform',
} as const;

/**
 * Credential properties returned by the authenticator.
 */
export type PasskeyCompletAuthenticationRequestBodyClientExtensionResultsCredProps = {
  /** Whether the credential is a resident key. */
  rk?: boolean;
};

/**
 * Results from any WebAuthn extensions used during authentication.
 */
export type PasskeyCompletAuthenticationRequestBodyClientExtensionResults = {
  /** Indicates if the AppID extension was used. */
  appid?: boolean;
  /** Credential properties returned by the authenticator. */
  credProps?: PasskeyCompletAuthenticationRequestBodyClientExtensionResultsCredProps;
  /** Indicates if the `hmac-secret` extension was used. */
  hmacCreateSecret?: boolean;
};

/**
 * Contains the raw cryptographic materials returned by the authenticator, required for verifying the authentication response.

 */
export type PasskeyCompletAuthenticationRequestBodyResponse = {
  /** Base64url-encoded JSON object that was passed to the authenticator. */
  clientDataJSON: string;
  /** Base64url-encoded authenticator data containing RP ID hash, flags, and signature counter. */
  authenticatorData: string;
  /** Base64url-encoded signature that proves possession of the private key. */
  signature: string;
  /** Base64url-encoded identifier for the user account associated with the credential. */
  userHandle: string;
};

/**
 * Represents the **WebAuthn authentication response** sent by the browser after calling `navigator.credentials.get()` during the passkey sign-in process. This object contains all cryptographic data needed by the backend to verify the authenticity and integrity of the authentication ceremony.

 */
export interface PasskeyCompletAuthenticationRequestBody {
  /** The base64url-encoded credential ID uniquely identifying the passkey credential.
 */
  id: string;
  /** The raw credential ID in base64url format. Usually identical to `id` but encoded differently.
 */
  rawId: string;
  /** The credential type. For WebAuthn, always `"public-key"`. */
  type: PasskeyCompletAuthenticationRequestBodyType;
  /** Indicates the attachment modality of the authenticator:
- `"platform"`: built into the device (e.g. Touch ID, Windows Hello)
- `"cross-platform"`: external authenticator (e.g. security key)
 */
  authenticatorAttachment?: PasskeyCompletAuthenticationRequestBodyAuthenticatorAttachment;
  /** Results from any WebAuthn extensions used during authentication. */
  clientExtensionResults?: PasskeyCompletAuthenticationRequestBodyClientExtensionResults;
  /** Contains the raw cryptographic materials returned by the authenticator, required for verifying the authentication response.
 */
  response: PasskeyCompletAuthenticationRequestBodyResponse;
}

export type RegistrationSuccessReponseStatusCode = typeof RegistrationSuccessReponseStatusCode[keyof typeof RegistrationSuccessReponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RegistrationSuccessReponseStatusCode = {
  NUMBER_201: 201,
} as const;

export type RegistrationSuccessReponseDataNextStep = typeof RegistrationSuccessReponseDataNextStep[keyof typeof RegistrationSuccessReponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RegistrationSuccessReponseDataNextStep = {
  CONFIRM_SIGN_UP: 'CONFIRM_SIGN_UP',
} as const;

export type RegistrationSuccessReponseData = {
  user?: UserData;
  isVerificationEmailSend?: boolean;
  nextStep?: RegistrationSuccessReponseDataNextStep;
};

export interface RegistrationSuccessReponse {
  success: boolean;
  statusCode: RegistrationSuccessReponseStatusCode;
  message: string;
  data: RegistrationSuccessReponseData;
  metadata: ResponseMetadata;
}

export type LoginEmailVerificationPendingResponseStatusCode = typeof LoginEmailVerificationPendingResponseStatusCode[keyof typeof LoginEmailVerificationPendingResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LoginEmailVerificationPendingResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type LoginEmailVerificationPendingResponseDataNextStep = typeof LoginEmailVerificationPendingResponseDataNextStep[keyof typeof LoginEmailVerificationPendingResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LoginEmailVerificationPendingResponseDataNextStep = {
  CONFIRM_SIGN_UP: 'CONFIRM_SIGN_UP',
} as const;

export type LoginEmailVerificationPendingResponseData = {
  nextStep?: LoginEmailVerificationPendingResponseDataNextStep;
};

export interface LoginEmailVerificationPendingResponse {
  success: boolean;
  statusCode: LoginEmailVerificationPendingResponseStatusCode;
  message: string;
  data: LoginEmailVerificationPendingResponseData;
  metadata: ResponseMetadata;
}

export type LoginSuccessResponseStatusCode = typeof LoginSuccessResponseStatusCode[keyof typeof LoginSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LoginSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type LoginSuccessResponseDataNextStep = typeof LoginSuccessResponseDataNextStep[keyof typeof LoginSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LoginSuccessResponseDataNextStep = {
  OK: 'OK',
} as const;

export type LoginSuccessResponseData = {
  user: UserData;
  nextStep: LoginSuccessResponseDataNextStep;
  mfaRequired: boolean;
};

export interface LoginSuccessResponse {
  success: boolean;
  statusCode: LoginSuccessResponseStatusCode;
  message: string;
  data: LoginSuccessResponseData;
  metadata: ResponseMetadata;
}

export type MFAPendingResponseStatusCode = typeof MFAPendingResponseStatusCode[keyof typeof MFAPendingResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFAPendingResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type MFAPendingResponseDataNextStep = typeof MFAPendingResponseDataNextStep[keyof typeof MFAPendingResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFAPendingResponseDataNextStep = {
  MFA_REQUIRED: 'MFA_REQUIRED',
} as const;

export type MFAPendingResponseData = {
  nextStep: MFAPendingResponseDataNextStep;
  mfaRequired: boolean;
};

export interface MFAPendingResponse {
  success: boolean;
  statusCode: MFAPendingResponseStatusCode;
  message: string;
  data: MFAPendingResponseData;
  metadata: ResponseMetadata;
}

export type EmailConfirmedSuccessResponseStatusCode = typeof EmailConfirmedSuccessResponseStatusCode[keyof typeof EmailConfirmedSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmailConfirmedSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type EmailConfirmedSuccessResponseDataNextStep = typeof EmailConfirmedSuccessResponseDataNextStep[keyof typeof EmailConfirmedSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmailConfirmedSuccessResponseDataNextStep = {
  CONFIRMED_EMAIL_RETURN_TO_LOGIN: 'CONFIRMED_EMAIL_RETURN_TO_LOGIN',
} as const;

export type EmailConfirmedSuccessResponseData = {
  nextStep: EmailConfirmedSuccessResponseDataNextStep;
};

export interface EmailConfirmedSuccessResponse {
  success: boolean;
  statusCode: EmailConfirmedSuccessResponseStatusCode;
  message: string;
  data: EmailConfirmedSuccessResponseData;
  metadata: ResponseMetadata;
}

export type ForgotPasswordSuccessResponseStatusCode = typeof ForgotPasswordSuccessResponseStatusCode[keyof typeof ForgotPasswordSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ForgotPasswordSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type ForgotPasswordSuccessResponseDataNextStep = typeof ForgotPasswordSuccessResponseDataNextStep[keyof typeof ForgotPasswordSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ForgotPasswordSuccessResponseDataNextStep = {
  OK: 'OK',
} as const;

export type ForgotPasswordSuccessResponseData = {
  nextStep: ForgotPasswordSuccessResponseDataNextStep;
  mfaRequired: boolean;
};

export interface ForgotPasswordSuccessResponse {
  success: boolean;
  statusCode: ForgotPasswordSuccessResponseStatusCode;
  message: string;
  data: ForgotPasswordSuccessResponseData;
  metadata: ResponseMetadata;
}

export type ResetPasswordSuccessResponseStatusCode = typeof ResetPasswordSuccessResponseStatusCode[keyof typeof ResetPasswordSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResetPasswordSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type ResetPasswordSuccessResponseDataNextStep = typeof ResetPasswordSuccessResponseDataNextStep[keyof typeof ResetPasswordSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResetPasswordSuccessResponseDataNextStep = {
  OK: 'OK',
} as const;

export type ResetPasswordSuccessResponseData = {
  nextStep: ResetPasswordSuccessResponseDataNextStep;
};

export interface ResetPasswordSuccessResponse {
  success: boolean;
  statusCode: ResetPasswordSuccessResponseStatusCode;
  message: string;
  data: ResetPasswordSuccessResponseData;
  metadata: ResponseMetadata;
}

export type RefreshTokenEndpointSuccessResponseStatusCode = typeof RefreshTokenEndpointSuccessResponseStatusCode[keyof typeof RefreshTokenEndpointSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RefreshTokenEndpointSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type RefreshTokenEndpointSuccessResponseDataNextStep = typeof RefreshTokenEndpointSuccessResponseDataNextStep[keyof typeof RefreshTokenEndpointSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RefreshTokenEndpointSuccessResponseDataNextStep = {
  OK: 'OK',
} as const;

export type RefreshTokenEndpointSuccessResponseData = {
  nextStep: RefreshTokenEndpointSuccessResponseDataNextStep;
};

export interface RefreshTokenEndpointSuccessResponse {
  success: boolean;
  statusCode: RefreshTokenEndpointSuccessResponseStatusCode;
  message: string;
  data: RefreshTokenEndpointSuccessResponseData;
  metadata: ResponseMetadata;
}

export type LogoutSuccessResponseStatusCode = typeof LogoutSuccessResponseStatusCode[keyof typeof LogoutSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LogoutSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type LogoutSuccessResponseDataNextStep = typeof LogoutSuccessResponseDataNextStep[keyof typeof LogoutSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LogoutSuccessResponseDataNextStep = {
  LOGOUT: 'LOGOUT',
} as const;

export type LogoutSuccessResponseData = {
  nextStep: LogoutSuccessResponseDataNextStep;
};

export interface LogoutSuccessResponse {
  success: boolean;
  statusCode: LogoutSuccessResponseStatusCode;
  message: string;
  data: LogoutSuccessResponseData;
  metadata: ResponseMetadata;
}

export type MagicLinkSignUpSuccessResponseStatusCode = typeof MagicLinkSignUpSuccessResponseStatusCode[keyof typeof MagicLinkSignUpSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MagicLinkSignUpSuccessResponseStatusCode = {
  NUMBER_201: 201,
} as const;

export type MagicLinkSignUpSuccessResponseDataNextStep = typeof MagicLinkSignUpSuccessResponseDataNextStep[keyof typeof MagicLinkSignUpSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MagicLinkSignUpSuccessResponseDataNextStep = {
  CHECK_EMAIL_FOR_MAGIC_LINK: 'CHECK_EMAIL_FOR_MAGIC_LINK',
} as const;

export type MagicLinkSignUpSuccessResponseData = {
  user?: UserData;
  isMagicLinkEmailSend?: boolean;
  nextStep?: MagicLinkSignUpSuccessResponseDataNextStep;
};

export interface MagicLinkSignUpSuccessResponse {
  success: boolean;
  statusCode: MagicLinkSignUpSuccessResponseStatusCode;
  message: string;
  data: MagicLinkSignUpSuccessResponseData;
  metadata: ResponseMetadata;
}

export type MagicLinkSignInSuccessResponseStatusCode = typeof MagicLinkSignInSuccessResponseStatusCode[keyof typeof MagicLinkSignInSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MagicLinkSignInSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type MagicLinkSignInSuccessResponseDataNextStep = typeof MagicLinkSignInSuccessResponseDataNextStep[keyof typeof MagicLinkSignInSuccessResponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MagicLinkSignInSuccessResponseDataNextStep = {
  CHECK_EMAIL_FOR_MAGIC_LINK: 'CHECK_EMAIL_FOR_MAGIC_LINK',
} as const;

export type MagicLinkSignInSuccessResponseData = {
  isMagicLinkEmailSend?: boolean;
  nextStep?: MagicLinkSignInSuccessResponseDataNextStep;
};

export interface MagicLinkSignInSuccessResponse {
  success: boolean;
  statusCode: MagicLinkSignInSuccessResponseStatusCode;
  message: string;
  data: MagicLinkSignInSuccessResponseData;
  metadata: ResponseMetadata;
}

export type MfaSetupResponseStatusCode = typeof MfaSetupResponseStatusCode[keyof typeof MfaSetupResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MfaSetupResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type MfaSetupResponseData = {
  /**
   * Base32-encoded TOTP secret for the user. This secret is used to generate OTP codes.
   * @pattern ^[A-Z2-7]+=*$
   */
  secret: string;
  /** Base64-encoded PNG image of the QR code for TOTP setup. Can be rendered in clients as an image. */
  qrImageUrl: string;
};

export interface MfaSetupResponse {
  success: boolean;
  statusCode: MfaSetupResponseStatusCode;
  message: string;
  data: MfaSetupResponseData;
  metadata: ResponseMetadata;
}

export type MFAVerifySetupSuccessResponseStatusCode = typeof MFAVerifySetupSuccessResponseStatusCode[keyof typeof MFAVerifySetupSuccessResponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFAVerifySetupSuccessResponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type MFAVerifySetupSuccessResponseDataUserPreferences = {
  enable2FA?: boolean;
  backupCodes: string[];
};

export type MFAVerifySetupSuccessResponseData = {
  userPreferences: MFAVerifySetupSuccessResponseDataUserPreferences;
};

export interface MFAVerifySetupSuccessResponse {
  success: boolean;
  statusCode: MFAVerifySetupSuccessResponseStatusCode;
  message: string;
  data: MFAVerifySetupSuccessResponseData;
  metadata: ResponseMetadata;
}

export type MFARevokeSuccessReponseStatusCode = typeof MFARevokeSuccessReponseStatusCode[keyof typeof MFARevokeSuccessReponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFARevokeSuccessReponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type MFARevokeSuccessReponseData = {
  user?: UserData;
};

export interface MFARevokeSuccessReponse {
  success: boolean;
  statusCode: MFARevokeSuccessReponseStatusCode;
  message: string;
  data: MFARevokeSuccessReponseData;
  metadata: ResponseMetadata;
}

export type MFARequestChangePasswordSuccessReponseStatusCode = typeof MFARequestChangePasswordSuccessReponseStatusCode[keyof typeof MFARequestChangePasswordSuccessReponseStatusCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFARequestChangePasswordSuccessReponseStatusCode = {
  NUMBER_200: 200,
} as const;

export type MFARequestChangePasswordSuccessReponseDataNextStep = typeof MFARequestChangePasswordSuccessReponseDataNextStep[keyof typeof MFARequestChangePasswordSuccessReponseDataNextStep];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFARequestChangePasswordSuccessReponseDataNextStep = {
  OK: 'OK',
} as const;

export type MFARequestChangePasswordSuccessReponseData = {
  nextStep: MFARequestChangePasswordSuccessReponseDataNextStep;
};

export interface MFARequestChangePasswordSuccessReponse {
  success: boolean;
  statusCode: MFARequestChangePasswordSuccessReponseStatusCode;
  message: string;
  data: MFARequestChangePasswordSuccessReponseData;
  metadata: ResponseMetadata;
}

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsRp = {
  /** The display name of the application (Relying Party).  This is shown to the user during registration/authentication.
 */
  name?: string;
  /** The unique identifier of the Relying Party, usually the domain name.  Used by the browser to validate the registration request and prevent phishing.
 */
  id?: string;
};

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsUser = {
  /** Base64 or URL-safe encoded user ID */
  id?: string;
  name?: string;
  displayName?: string;
};

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsPubKeyCredParamsItem = {
  alg: number;
  type: string;
};

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAttestation = typeof PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAttestation[keyof typeof PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAttestation];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAttestation = {
  direct: 'direct',
} as const;

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsExcludeCredentialsItem = { [key: string]: unknown };

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionResidentKey = typeof PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionResidentKey[keyof typeof PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionResidentKey];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionResidentKey = {
  required: 'required',
} as const;

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionUserVerification = typeof PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionUserVerification[keyof typeof PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionUserVerification];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionUserVerification = {
  required: 'required',
} as const;

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelection = {
  residentKey?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionResidentKey;
  requireResidentKey?: boolean;
  userVerification?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelectionUserVerification;
};

export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsExtensions = {
  credProps?: boolean;
};

/**
 * WebAuthn options to complete the passkey registration on the client side.
 */
export type PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOpts = {
  /** Base64-encoded challenge for WebAuthn registration. */
  challenge?: string;
  rp?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsRp;
  user?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsUser;
  /** The cryptographic algorithms supported by the relying party for the public-key credential.  Each object specifies the algorithm (`alg`) and type (`type`).  These algorithms correspond to the COSE algorithm identifiers:
  -7: ES256 (ECDSA w/ SHA-256)
  -8: EdDSA (Ed25519)
  -257: RS256 (RSASSA-PKCS1-v1_5 w/ SHA-256)
 */
  pubKeyCredParams?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsPubKeyCredParamsItem[];
  /** Timeout for the operation in milliseconds */
  timeout?: number;
  attestation?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAttestation;
  excludeCredentials?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsExcludeCredentialsItem[];
  authenticatorSelection?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsAuthenticatorSelection;
  extensions?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOptsExtensions;
  hints?: string[];
};

export type PasskeyGenerateSignUpSessionSuccessResponseData = {
  /** WebAuthn options to complete the passkey registration on the client side. */
  publicKeyOpts?: PasskeyGenerateSignUpSessionSuccessResponseDataPublicKeyOpts;
};

export interface PasskeyGenerateSignUpSessionSuccessResponse {
  /** HTTP status code of the response. */
  statusCode?: number;
  /** Indicates that the request was successful. */
  success?: boolean;
  /** Human-readable message describing the response. */
  message?: string;
  data?: PasskeyGenerateSignUpSessionSuccessResponseData;
  metadata?: ResponseMetadata;
}

export type PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType = typeof PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType[keyof typeof PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType = {
  'public-key': 'public-key',
} as const;

export type PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem = typeof PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem[keyof typeof PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem = {
  ble: 'ble',
  cable: 'cable',
  hybrid: 'hybrid',
  internal: 'internal',
  nfc: 'nfc',
  'smart-card': 'smart-card',
  usb: 'usb',
} as const;

export type PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItem = {
  /** Base64URL-encoded identifier of the allowed credential. */
  id?: string;
  type?: PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType;
  /** Optional list of transports supported by this credential. */
  transports?: PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem[];
};

/**
 * Indicates whether the authenticator must perform user verification.
 */
export type PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification = typeof PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification[keyof typeof PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification = {
  required: 'required',
  preferred: 'preferred',
  discouraged: 'discouraged',
} as const;

/**
 * Options provided to the client for completing the WebAuthn authentication ceremony.
 */
export type PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptions = {
  /** The relying party identifier, usually the domain name of your web application. */
  rpId: string;
  /** A unique cryptographic challenge generated by the server to prevent replay attacks. */
  challenge: string;
  /** A list of previously registered credentials that are allowed for authentication.  
If empty, the authenticator may select any credential associated with the user.
 */
  allowCredentials: PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItem[];
  /** The time, in milliseconds, that the client is allowed to take to complete the authentication. */
  timeout: number;
  /** Indicates whether the authenticator must perform user verification. */
  userVerification: PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification;
};

/**
 * Contains the created public key credential request options used by the client to proceed with WebAuthn authentication.
 */
export type PasskeyGenerateSignInSessionSuccessResponseData = {
  /** Options provided to the client for completing the WebAuthn authentication ceremony. */
  publicKeyCredentialRequestOptions?: PasskeyGenerateSignInSessionSuccessResponseDataPublicKeyCredentialRequestOptions;
};

/**
 * Response returned when a new passkey authentication session has been successfully created.
 */
export interface PasskeyGenerateSignInSessionSuccessResponse {
  /** HTTP status code indicating that the passkey session was successfully created. */
  statusCode: number;
  /** Indicates whether the operation was successful. */
  success: boolean;
  /** A human-readable message describing the result of the operation. */
  message: string;
  /** Contains the created public key credential request options used by the client to proceed with WebAuthn authentication. */
  data: PasskeyGenerateSignInSessionSuccessResponseData;
  metadata: ResponseMetadata;
}

export type PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType = typeof PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType[keyof typeof PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType = {
  'public-key': 'public-key',
} as const;

export type PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem = typeof PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem[keyof typeof PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem = {
  ble: 'ble',
  cable: 'cable',
  hybrid: 'hybrid',
  internal: 'internal',
  nfc: 'nfc',
  'smart-card': 'smart-card',
  usb: 'usb',
} as const;

export type PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItem = {
  /** Base64URL-encoded identifier of the allowed credential. */
  id?: string;
  type?: PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemType;
  /** Optional list of transports supported by this credential. */
  transports?: PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItemTransportsItem[];
};

/**
 * Indicates whether the authenticator must perform user verification.
 */
export type PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification = typeof PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification[keyof typeof PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification = {
  required: 'required',
  preferred: 'preferred',
  discouraged: 'discouraged',
} as const;

/**
 * Options provided to the client for completing the WebAuthn authentication ceremony.
 */
export type PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptions = {
  /** The relying party identifier, usually the domain name of your web application. */
  rpId: string;
  /** A unique cryptographic challenge generated by the server to prevent replay attacks. */
  challenge: string;
  /** A list of previously registered credentials that are allowed for authentication.  
If empty, the authenticator may select any credential associated with the user.
 */
  allowCredentials: PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsAllowCredentialsItem[];
  /** The time, in milliseconds, that the client is allowed to take to complete the authentication. */
  timeout: number;
  /** Indicates whether the authenticator must perform user verification. */
  userVerification: PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptionsUserVerification;
};

/**
 * Contains the created public key credential request options used by the client to proceed with WebAuthn authentication.
 */
export type PasskeyGenerateRemoveKeySuccessResponseData = {
  /** Options provided to the client for completing the WebAuthn authentication ceremony. */
  publicKeyCredentialRequestOptions?: PasskeyGenerateRemoveKeySuccessResponseDataPublicKeyCredentialRequestOptions;
};

/**
 * Response returned when a new passkey authentication session has been successfully created.
 */
export interface PasskeyGenerateRemoveKeySuccessResponse {
  /** HTTP status code indicating that the passkey session was successfully created. */
  statusCode: number;
  /** Indicates whether the operation was successful. */
  success: boolean;
  /** A human-readable message describing the result of the operation. */
  message: string;
  /** Contains the created public key credential request options used by the client to proceed with WebAuthn authentication. */
  data: PasskeyGenerateRemoveKeySuccessResponseData;
  metadata: ResponseMetadata;
}

/**
 * Contains the newly added passkey details.
 */
export type PasskeyAddedSuccessResponseData = {
  passkey?: PasskeyData;
};

/**
 * Response returned when a new passkey has been successfully registered and added to the user account.

 */
export interface PasskeyAddedSuccessResponse {
  /** Indicates whether the operation was successful. */
  success: boolean;
  /** HTTP status code associated with this response. */
  statusCode: number;
  /** Human-readable message describing the result of the operation. */
  message: string;
  /** Contains the newly added passkey details. */
  data: PasskeyAddedSuccessResponseData;
  metadata: ResponseMetadata;
}

export type PasskeyRemovedSuccessResponseData = { [key: string]: unknown };

/**
 * Response returned when a new passkey has been successfully registered and added to the user account.

 */
export interface PasskeyRemovedSuccessResponse {
  /** Indicates whether the operation was successful. */
  success: boolean;
  /** HTTP status code associated with this response. */
  statusCode: number;
  /** Human-readable message describing the result of the operation. */
  message: string;
  data: PasskeyRemovedSuccessResponseData;
  metadata: ResponseMetadata;
}

export type PasskeyGetAllPasskeyByUserIdSuccessResponseDataPasskeysItemAaguid = {
  /** The name of the passkey provider. */
  name?: string;
  /** The base64 encoded SVG for the dark theme icon. */
  icon_dark?: string;
  /** The base64 encoded SVG for the light theme icon. */
  icon_light?: string;
};

export type PasskeyGetAllPasskeyByUserIdSuccessResponseDataPasskeysItem = {
  aaguid?: PasskeyGetAllPasskeyByUserIdSuccessResponseDataPasskeysItemAaguid;
  /** The unique identifier of the passkey credential. */
  credentialId?: string;
  /** The date and time when the passkey was created. */
  createdAt?: string;
  /** The date and time when the passkey was last used. */
  lastUsed?: string;
};

export type PasskeyGetAllPasskeyByUserIdSuccessResponseData = {
  passkeys?: PasskeyGetAllPasskeyByUserIdSuccessResponseDataPasskeysItem[];
};

export type PasskeyGetAllPasskeyByUserIdSuccessResponseMetadata = {
  /** A unique identifier for the request. */
  requestId?: string;
  /** The total number of passkeys retrieved. */
  count?: number;
};

export interface PasskeyGetAllPasskeyByUserIdSuccessResponse {
  /** Indicates whether the request was successful. */
  success?: boolean;
  /** HTTP status code. */
  statusCode?: number;
  /** A message summarizing the request result. */
  message?: string;
  data?: PasskeyGetAllPasskeyByUserIdSuccessResponseData;
  metadata?: PasskeyGetAllPasskeyByUserIdSuccessResponseMetadata;
}

export type GetAllSessionsSuccessResponseDataSessionsItemUserAgent = {
  browser?: string;
  version?: string;
  os?: string;
  platform?: string;
};

export type GetAllSessionsSuccessResponseDataSessionsItem = {
  /** Unique identifier of the session. */
  _id?: string;
  /** Unique identifier of the user who owns the session. */
  userId?: string;
  userAgent?: GetAllSessionsSuccessResponseDataSessionsItemUserAgent;
  /** The expiration date and time of the session. */
  expiredAt?: string;
  /** The creation date and time of the session. */
  createdAt?: string;
  /** Indicates if this is the current session. */
  isCurrent?: boolean;
};

export type GetAllSessionsSuccessResponseData = {
  sessions?: GetAllSessionsSuccessResponseDataSessionsItem[];
};

export interface GetAllSessionsSuccessResponse {
  /** Indicates whether the operation was successful */
  success?: boolean;
  /** HTTP status code of the response */
  statusCode?: number;
  message?: string;
  data?: GetAllSessionsSuccessResponseData;
  metadata?: ResponseMetadata;
}

export type GetCurrentSessionSuccessResponseData = {
  user?: UserData;
};

export interface GetCurrentSessionSuccessResponse {
  /** Indicates whether the operation was successful */
  success: boolean;
  /** HTTP status code of the response */
  statusCode: number;
  message: string;
  data: GetCurrentSessionSuccessResponseData;
  metadata: ResponseMetadata;
}

export type DeleteSessionByIdSuccessResponseData = {
  /** If the deleted session was the current session, indicates the next action for the client (e.g., LOGIN.LOGOUT).
 */
  nextStep?: string;
};

export interface DeleteSessionByIdSuccessResponse {
  /** Indicates whether the operation was successful */
  success: boolean;
  /** HTTP status code of the response */
  statusCode: number;
  /** A human-readable message describing the result */
  message: string;
  data: DeleteSessionByIdSuccessResponseData;
  metadata: ResponseMetadata;
}

export type InternalServerErrorErrorCode = typeof InternalServerErrorErrorCode[keyof typeof InternalServerErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InternalServerErrorErrorCode = {
  INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
} as const;

export interface InternalServerError {
  success: boolean;
  message: string;
  errorCode: InternalServerErrorErrorCode;
  requestId: string;
}

export type ForbiddenErrorErrorCode = typeof ForbiddenErrorErrorCode[keyof typeof ForbiddenErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ForbiddenErrorErrorCode = {
  ACCESS_FORBIDDEN: 'ACCESS_FORBIDDEN',
} as const;

export interface ForbiddenError {
  success: boolean;
  message: string;
  errorCode: ForbiddenErrorErrorCode;
  requestId: string;
}

export type TooManyRequestsErrorErrorCode = typeof TooManyRequestsErrorErrorCode[keyof typeof TooManyRequestsErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TooManyRequestsErrorErrorCode = {
  TOO_MANY_REQUESTS: 'TOO_MANY_REQUESTS',
} as const;

export interface TooManyRequestsError {
  success: boolean;
  message: string;
  errorCode: TooManyRequestsErrorErrorCode;
  requestId: string;
}

export type EmailServiceErrorErrorCode = typeof EmailServiceErrorErrorCode[keyof typeof EmailServiceErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmailServiceErrorErrorCode = {
  EMAIL_SERVICE_ERROR: 'EMAIL_SERVICE_ERROR',
} as const;

export interface EmailServiceError {
  success: boolean;
  message: string;
  errorCode: EmailServiceErrorErrorCode;
  requestId: string;
}

export type InvalidRequestBodyValidationErrorErrorCode = typeof InvalidRequestBodyValidationErrorErrorCode[keyof typeof InvalidRequestBodyValidationErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvalidRequestBodyValidationErrorErrorCode = {
  VALIDATION_ERROR_INVALID_REQUEST_BODY: 'VALIDATION_ERROR_INVALID_REQUEST_BODY',
} as const;

export type InvalidRequestBodyValidationErrorErrorsItem = {
  field: string;
  message: string;
};

export interface InvalidRequestBodyValidationError {
  success: boolean;
  message: string;
  errorCode: InvalidRequestBodyValidationErrorErrorCode;
  requestId: string;
  /** @minItems 1 */
  errors: InvalidRequestBodyValidationErrorErrorsItem[];
}

export type EmailAlreadyExistsErrorErrorCode = typeof EmailAlreadyExistsErrorErrorCode[keyof typeof EmailAlreadyExistsErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmailAlreadyExistsErrorErrorCode = {
  AUTH_EMAIL_ALREADY_EXISTS: 'AUTH_EMAIL_ALREADY_EXISTS',
} as const;

export interface EmailAlreadyExistsError {
  success: boolean;
  message: string;
  errorCode: EmailAlreadyExistsErrorErrorCode;
  requestId: string;
}

export type UserNotFoundErrorErrorCode = typeof UserNotFoundErrorErrorCode[keyof typeof UserNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserNotFoundErrorErrorCode = {
  AUTH_USER_NOT_FOUND: 'AUTH_USER_NOT_FOUND',
} as const;

export interface UserNotFoundError {
  success: boolean;
  message: string;
  errorCode: UserNotFoundErrorErrorCode;
  requestId: string;
}

export type InvalidCredentialsErrorErrorCode = typeof InvalidCredentialsErrorErrorCode[keyof typeof InvalidCredentialsErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvalidCredentialsErrorErrorCode = {
  AUTH_INVALID_CREDENTIALS: 'AUTH_INVALID_CREDENTIALS',
} as const;

export interface InvalidCredentialsError {
  success: boolean;
  message: string;
  errorCode: InvalidCredentialsErrorErrorCode;
  requestId: string;
}

export type PasswordReuseNotAllowedErrorCode = typeof PasswordReuseNotAllowedErrorCode[keyof typeof PasswordReuseNotAllowedErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasswordReuseNotAllowedErrorCode = {
  AUTH_PASSWORD_REUSE_NOT_ALLOWED: 'AUTH_PASSWORD_REUSE_NOT_ALLOWED',
} as const;

export interface PasswordReuseNotAllowed {
  success: boolean;
  message: string;
  errorCode: PasswordReuseNotAllowedErrorCode;
  requestId: string;
}

export type VerificationCodeNotFoundErrorErrorCode = typeof VerificationCodeNotFoundErrorErrorCode[keyof typeof VerificationCodeNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VerificationCodeNotFoundErrorErrorCode = {
  VERIFICATION_CODE_ERROR_CODE_NOT_FOUND: 'VERIFICATION_CODE_ERROR_CODE_NOT_FOUND',
} as const;

export interface VerificationCodeNotFoundError {
  success: boolean;
  message: string;
  errorCode: VerificationCodeNotFoundErrorErrorCode;
  requestId: string;
}

export type VerificationCodeExpiredErrorErrorCode = typeof VerificationCodeExpiredErrorErrorCode[keyof typeof VerificationCodeExpiredErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VerificationCodeExpiredErrorErrorCode = {
  VERIFICATION_CODE_ERROR_CODE_EXPIRED: 'VERIFICATION_CODE_ERROR_CODE_EXPIRED',
} as const;

export interface VerificationCodeExpiredError {
  success: boolean;
  message: string;
  errorCode: VerificationCodeExpiredErrorErrorCode;
  requestId: string;
}

export type VerificationCodeConsumedErrorErrorCode = typeof VerificationCodeConsumedErrorErrorCode[keyof typeof VerificationCodeConsumedErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VerificationCodeConsumedErrorErrorCode = {
  VERIFICATION_CODE_ERROR_CODE_CONSUMED: 'VERIFICATION_CODE_ERROR_CODE_CONSUMED',
} as const;

export interface VerificationCodeConsumedError {
  success: boolean;
  message: string;
  errorCode: VerificationCodeConsumedErrorErrorCode;
  requestId: string;
}

export type AuthenticationTokenNotFoundErrorErrorCode = typeof AuthenticationTokenNotFoundErrorErrorCode[keyof typeof AuthenticationTokenNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationTokenNotFoundErrorErrorCode = {
  AUTH_TOKEN_NOT_FOUND: 'AUTH_TOKEN_NOT_FOUND',
} as const;

export interface AuthenticationTokenNotFoundError {
  success: boolean;
  message: string;
  errorCode: AuthenticationTokenNotFoundErrorErrorCode;
  requestId: string;
}

export type AuthenticationTokenUserNotFoundErrorErrorCode = typeof AuthenticationTokenUserNotFoundErrorErrorCode[keyof typeof AuthenticationTokenUserNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationTokenUserNotFoundErrorErrorCode = {
  AUTH_TOKEN_USER_NOT_FOUND: 'AUTH_TOKEN_USER_NOT_FOUND',
} as const;

export interface AuthenticationTokenUserNotFoundError {
  success: boolean;
  message: string;
  errorCode: AuthenticationTokenUserNotFoundErrorErrorCode;
  requestId: string;
}

export type AuthenticationTokenInvalidSessionErrorErrorCode = typeof AuthenticationTokenInvalidSessionErrorErrorCode[keyof typeof AuthenticationTokenInvalidSessionErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationTokenInvalidSessionErrorErrorCode = {
  AUTH_TOKEN_SESSION_INVALID: 'AUTH_TOKEN_SESSION_INVALID',
} as const;

export interface AuthenticationTokenInvalidSessionError {
  success: boolean;
  message: string;
  errorCode: AuthenticationTokenInvalidSessionErrorErrorCode;
  requestId: string;
}

export type AuthenticationTokenSessionMismatchErrorErrorCode = typeof AuthenticationTokenSessionMismatchErrorErrorCode[keyof typeof AuthenticationTokenSessionMismatchErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationTokenSessionMismatchErrorErrorCode = {
  AUTH_TOKEN_SESSION_MISMATCH: 'AUTH_TOKEN_SESSION_MISMATCH',
} as const;

export interface AuthenticationTokenSessionMismatchError {
  success: boolean;
  message: string;
  errorCode: AuthenticationTokenSessionMismatchErrorErrorCode;
  requestId: string;
}

export type AuthenticationTokenInvalidTokenErorrErrorCode = typeof AuthenticationTokenInvalidTokenErorrErrorCode[keyof typeof AuthenticationTokenInvalidTokenErorrErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationTokenInvalidTokenErorrErrorCode = {
  AUTH_TOKEN_INVALID: 'AUTH_TOKEN_INVALID',
} as const;

export interface AuthenticationTokenInvalidTokenErorr {
  success: boolean;
  message: string;
  errorCode: AuthenticationTokenInvalidTokenErorrErrorCode;
  requestId: string;
}

export type AuthenticationTokenExpiredErrorErrorCode = typeof AuthenticationTokenExpiredErrorErrorCode[keyof typeof AuthenticationTokenExpiredErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationTokenExpiredErrorErrorCode = {
  AUTH_TOKEN_EXPIRED: 'AUTH_TOKEN_EXPIRED',
} as const;

export interface AuthenticationTokenExpiredError {
  success: boolean;
  message: string;
  errorCode: AuthenticationTokenExpiredErrorErrorCode;
  requestId: string;
}

export type AccessTokenTypeErrorErrorCode = typeof AccessTokenTypeErrorErrorCode[keyof typeof AccessTokenTypeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccessTokenTypeErrorErrorCode = {
  AUTH_ACCESS_TOKEN_TYPE_INVALID: 'AUTH_ACCESS_TOKEN_TYPE_INVALID',
} as const;

export interface AccessTokenTypeError {
  success: boolean;
  message: string;
  errorCode: AccessTokenTypeErrorErrorCode;
  requestId: string;
}

export type MFATokenTypeErrorErrorCode = typeof MFATokenTypeErrorErrorCode[keyof typeof MFATokenTypeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFATokenTypeErrorErrorCode = {
  AUTH_MFA_TOKEN_TYPE_INVALID: 'AUTH_MFA_TOKEN_TYPE_INVALID',
} as const;

export interface MFATokenTypeError {
  success: boolean;
  message: string;
  errorCode: MFATokenTypeErrorErrorCode;
  requestId: string;
}

export type MFATokenInvalidEndpointErrorErrorCode = typeof MFATokenInvalidEndpointErrorErrorCode[keyof typeof MFATokenInvalidEndpointErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFATokenInvalidEndpointErrorErrorCode = {
  AUTH_MFA_INVALID_ENDPOINT: 'AUTH_MFA_INVALID_ENDPOINT',
} as const;

export interface MFATokenInvalidEndpointError {
  success: boolean;
  message: string;
  errorCode: MFATokenInvalidEndpointErrorErrorCode;
  requestId: string;
}

export type MFATokenInvalidTokenPurposeErrorErrorCode = typeof MFATokenInvalidTokenPurposeErrorErrorCode[keyof typeof MFATokenInvalidTokenPurposeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFATokenInvalidTokenPurposeErrorErrorCode = {
  AUTH_TOKEN_INVALID_TYPE: 'AUTH_TOKEN_INVALID_TYPE',
} as const;

export interface MFATokenInvalidTokenPurposeError {
  success: boolean;
  message: string;
  errorCode: MFATokenInvalidTokenPurposeErrorErrorCode;
  requestId: string;
}

export type MFAForbiddenErrorErrorCode = typeof MFAForbiddenErrorErrorCode[keyof typeof MFAForbiddenErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MFAForbiddenErrorErrorCode = {
  ACCESS_FORBIDDEN: 'ACCESS_FORBIDDEN',
} as const;

export interface MFAForbiddenError {
  success: boolean;
  message: string;
  errorCode: MFAForbiddenErrorErrorCode;
  requestId: string;
}

export type MagicLinkTokenTypeErrorErrorCode = typeof MagicLinkTokenTypeErrorErrorCode[keyof typeof MagicLinkTokenTypeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MagicLinkTokenTypeErrorErrorCode = {
  AUTH_MAGIC_LINK_TOKEN_TYPE_INVALID: 'AUTH_MAGIC_LINK_TOKEN_TYPE_INVALID',
} as const;

export interface MagicLinkTokenTypeError {
  success: boolean;
  message: string;
  errorCode: MagicLinkTokenTypeErrorErrorCode;
  requestId: string;
}

export type RefreshTokenTypeErrorErrorCode = typeof RefreshTokenTypeErrorErrorCode[keyof typeof RefreshTokenTypeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RefreshTokenTypeErrorErrorCode = {
  AUTH_REFRESH_TOKEN_TYPE_INVALID: 'AUTH_REFRESH_TOKEN_TYPE_INVALID',
} as const;

export interface RefreshTokenTypeError {
  success: boolean;
  message: string;
  errorCode: RefreshTokenTypeErrorErrorCode;
  requestId: string;
}

export type RefreshTokenInvalidSessionErrorErrorCode = typeof RefreshTokenInvalidSessionErrorErrorCode[keyof typeof RefreshTokenInvalidSessionErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RefreshTokenInvalidSessionErrorErrorCode = {
  AUTH_REFRESH_TOKEN_SESSION_INVALID: 'AUTH_REFRESH_TOKEN_SESSION_INVALID',
} as const;

export interface RefreshTokenInvalidSessionError {
  success: boolean;
  message: string;
  errorCode: RefreshTokenInvalidSessionErrorErrorCode;
  requestId: string;
}

export type RefreshTokenExpiredSessionErrorErrorCode = typeof RefreshTokenExpiredSessionErrorErrorCode[keyof typeof RefreshTokenExpiredSessionErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RefreshTokenExpiredSessionErrorErrorCode = {
  AUTH_REFRESH_TOKEN_SESSION_EXPIRED: 'AUTH_REFRESH_TOKEN_SESSION_EXPIRED',
} as const;

export interface RefreshTokenExpiredSessionError {
  success: boolean;
  message: string;
  errorCode: RefreshTokenExpiredSessionErrorErrorCode;
  requestId: string;
}

export type MfaAlreadyEnabledErrorErrorCode = typeof MfaAlreadyEnabledErrorErrorCode[keyof typeof MfaAlreadyEnabledErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MfaAlreadyEnabledErrorErrorCode = {
  MFA_ALREADY_ENABLED: 'MFA_ALREADY_ENABLED',
} as const;

export interface MfaAlreadyEnabledError {
  success: boolean;
  message: string;
  errorCode: MfaAlreadyEnabledErrorErrorCode;
  requestId: string;
}

export type MfaAlreadyDisabledErrorErrorCode = typeof MfaAlreadyDisabledErrorErrorCode[keyof typeof MfaAlreadyDisabledErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MfaAlreadyDisabledErrorErrorCode = {
  MFA_ALREADY_DISABLED: 'MFA_ALREADY_DISABLED',
} as const;

export interface MfaAlreadyDisabledError {
  success: boolean;
  message: string;
  errorCode: MfaAlreadyDisabledErrorErrorCode;
  requestId: string;
}

export type MfaTemporarySecretExpiredErrorErrorCode = typeof MfaTemporarySecretExpiredErrorErrorCode[keyof typeof MfaTemporarySecretExpiredErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MfaTemporarySecretExpiredErrorErrorCode = {
  MFA_EXPIRED_TEMP_SECRET: 'MFA_EXPIRED_TEMP_SECRET',
} as const;

export interface MfaTemporarySecretExpiredError {
  success: boolean;
  message: string;
  errorCode: MfaTemporarySecretExpiredErrorErrorCode;
  requestId: string;
}

export type MfaInvalidVerificationCodeErrorErrorCode = typeof MfaInvalidVerificationCodeErrorErrorCode[keyof typeof MfaInvalidVerificationCodeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MfaInvalidVerificationCodeErrorErrorCode = {
  MFA_INVALID_VERIFICATION_CODE: 'MFA_INVALID_VERIFICATION_CODE',
} as const;

export interface MfaInvalidVerificationCodeError {
  success: boolean;
  message: string;
  errorCode: MfaInvalidVerificationCodeErrorErrorCode;
  requestId: string;
}

export type MfaNotEnabledErrorErrorCode = typeof MfaNotEnabledErrorErrorCode[keyof typeof MfaNotEnabledErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MfaNotEnabledErrorErrorCode = {
  MFA_NOT_ENABLED: 'MFA_NOT_ENABLED',
} as const;

export interface MfaNotEnabledError {
  success: boolean;
  message: string;
  errorCode: MfaNotEnabledErrorErrorCode;
  requestId: string;
}

export type InvalidBackupCodeErrorErrorCode = typeof InvalidBackupCodeErrorErrorCode[keyof typeof InvalidBackupCodeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvalidBackupCodeErrorErrorCode = {
  BACKUPCODE_INVALID_CODE: 'BACKUPCODE_INVALID_CODE',
} as const;

export interface InvalidBackupCodeError {
  success: boolean;
  message: string;
  errorCode: InvalidBackupCodeErrorErrorCode;
  requestId: string;
}

export type OIDCSessionNotFoundErrorErrorCode = typeof OIDCSessionNotFoundErrorErrorCode[keyof typeof OIDCSessionNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OIDCSessionNotFoundErrorErrorCode = {
  OIDC_SESSION_NOT_FOUND: 'OIDC_SESSION_NOT_FOUND',
} as const;

export interface OIDCSessionNotFoundError {
  success: boolean;
  message: string;
  errorCode: OIDCSessionNotFoundErrorErrorCode;
  requestId: string;
}

export type OIDCSessionExpiredErrorErrorCode = typeof OIDCSessionExpiredErrorErrorCode[keyof typeof OIDCSessionExpiredErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OIDCSessionExpiredErrorErrorCode = {
  OIDC_SESSION_CONSUMED: 'OIDC_SESSION_CONSUMED',
} as const;

export interface OIDCSessionExpiredError {
  success: boolean;
  message: string;
  errorCode: OIDCSessionExpiredErrorErrorCode;
  requestId: string;
}

export type OIDCSessionConsumedErrorErrorCode = typeof OIDCSessionConsumedErrorErrorCode[keyof typeof OIDCSessionConsumedErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OIDCSessionConsumedErrorErrorCode = {
  OIDC_SESSION_CONSUMED: 'OIDC_SESSION_CONSUMED',
} as const;

export interface OIDCSessionConsumedError {
  success: boolean;
  message: string;
  errorCode: OIDCSessionConsumedErrorErrorCode;
  requestId: string;
}

export type OIDCFailedAuthenticationErrorErrorCode = typeof OIDCFailedAuthenticationErrorErrorCode[keyof typeof OIDCFailedAuthenticationErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OIDCFailedAuthenticationErrorErrorCode = {
  OIDC_FAILED_AUTHENTIFICATION: 'OIDC_FAILED_AUTHENTIFICATION',
} as const;

export interface OIDCFailedAuthenticationError {
  success: boolean;
  message: string;
  errorCode: OIDCFailedAuthenticationErrorErrorCode;
  requestId: string;
}

export type PasskeyChallengeSessionNotFoundErrorErrorCode = typeof PasskeyChallengeSessionNotFoundErrorErrorCode[keyof typeof PasskeyChallengeSessionNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyChallengeSessionNotFoundErrorErrorCode = {
  PASSKEY_CHALLENGE_SESSION_INVALID: 'PASSKEY_CHALLENGE_SESSION_INVALID',
} as const;

export interface PasskeyChallengeSessionNotFoundError {
  success: boolean;
  message: string;
  errorCode: PasskeyChallengeSessionNotFoundErrorErrorCode;
  requestId: string;
}

export type PasskeyChallengeSessionConsumedErrorErrorCode = typeof PasskeyChallengeSessionConsumedErrorErrorCode[keyof typeof PasskeyChallengeSessionConsumedErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyChallengeSessionConsumedErrorErrorCode = {
  PASSKEY_CHALLENGE_SESSION_CONSUMED: 'PASSKEY_CHALLENGE_SESSION_CONSUMED',
} as const;

export interface PasskeyChallengeSessionConsumedError {
  success: boolean;
  message: string;
  errorCode: PasskeyChallengeSessionConsumedErrorErrorCode;
  requestId: string;
}

export type PasskeyChallengeSessionInvalidPurposeErrorErrorCode = typeof PasskeyChallengeSessionInvalidPurposeErrorErrorCode[keyof typeof PasskeyChallengeSessionInvalidPurposeErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyChallengeSessionInvalidPurposeErrorErrorCode = {
  PASSKEY_CHALLENGE_SESSION__INVALID_PURPOSE: 'PASSKEY_CHALLENGE_SESSION__INVALID_PURPOSE',
} as const;

export interface PasskeyChallengeSessionInvalidPurposeError {
  success: boolean;
  message: string;
  errorCode: PasskeyChallengeSessionInvalidPurposeErrorErrorCode;
  requestId: string;
}

export type PasskeyChallengeSessionExpiredErrorErrorCode = typeof PasskeyChallengeSessionExpiredErrorErrorCode[keyof typeof PasskeyChallengeSessionExpiredErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyChallengeSessionExpiredErrorErrorCode = {
  PASSKEY_CHALLENGE_SESSION__EXPIRED: 'PASSKEY_CHALLENGE_SESSION__EXPIRED',
} as const;

export interface PasskeyChallengeSessionExpiredError {
  success: boolean;
  message: string;
  errorCode: PasskeyChallengeSessionExpiredErrorErrorCode;
  requestId: string;
}

export type PasskeyChallengeVerificationErrorErrorCode = typeof PasskeyChallengeVerificationErrorErrorCode[keyof typeof PasskeyChallengeVerificationErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyChallengeVerificationErrorErrorCode = {
  PASSKEY_CHALENGE_VERIFICATION_ERROR: 'PASSKEY_CHALENGE_VERIFICATION_ERROR',
} as const;

export interface PasskeyChallengeVerificationError {
  success: boolean;
  message: string;
  errorCode: PasskeyChallengeVerificationErrorErrorCode;
  requestId: string;
}

export type PasskeyNotFoundErrorErrorCode = typeof PasskeyNotFoundErrorErrorCode[keyof typeof PasskeyNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PasskeyNotFoundErrorErrorCode = {
  PASSKEY_NOT_FOUND: 'PASSKEY_NOT_FOUND',
} as const;

export interface PasskeyNotFoundError {
  success: boolean;
  message: string;
  errorCode: PasskeyNotFoundErrorErrorCode;
  requestId: string;
}

export type UserSessionNotFoundErrorErrorCode = typeof UserSessionNotFoundErrorErrorCode[keyof typeof UserSessionNotFoundErrorErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSessionNotFoundErrorErrorCode = {
  AUTH_SESSION_NOT_FOUND: 'AUTH_SESSION_NOT_FOUND',
} as const;

export interface UserSessionNotFoundError {
  success: boolean;
  message: string;
  errorCode: UserSessionNotFoundErrorErrorCode;
  requestId: string;
}

export type InvalidAccessJwtTokenResponse = AuthenticationTokenNotFoundError | AccessTokenTypeError | AuthenticationTokenUserNotFoundError | AuthenticationTokenInvalidSessionError | AuthenticationTokenSessionMismatchError | AuthenticationTokenInvalidTokenErorr | AuthenticationTokenExpiredError;

export type InvalidMFAJwtTokenResponse = AuthenticationTokenNotFoundError | MFATokenTypeError | MFATokenInvalidEndpointError | MFATokenInvalidTokenPurposeError | AuthenticationTokenUserNotFoundError | AuthenticationTokenInvalidSessionError | AuthenticationTokenSessionMismatchError | AuthenticationTokenInvalidTokenErorr | AuthenticationTokenExpiredError;

export type InvalidMagicLinkJwtTokenResponse = AuthenticationTokenNotFoundError | MagicLinkTokenTypeError | AuthenticationTokenUserNotFoundError | AuthenticationTokenInvalidSessionError | AuthenticationTokenSessionMismatchError | AuthenticationTokenInvalidTokenErorr | AuthenticationTokenExpiredError;

export type InvalidRefreshJwtTokenResponse = RefreshTokenInvalidSessionError | AuthenticationTokenNotFoundError | RefreshTokenTypeError | AuthenticationTokenUserNotFoundError | RefreshTokenExpiredSessionError | AuthenticationTokenSessionMismatchError | AuthenticationTokenInvalidTokenErorr | AuthenticationTokenExpiredError;

export type PostAuthRegister400 = EmailAlreadyExistsError | InvalidRequestBodyValidationError;

export type PostAuthLogin200 = LoginEmailVerificationPendingResponse | MFAPendingResponse | LoginSuccessResponse;

export type PostAuthEmailVerifyBody = {
  code: string;
};

export type PostAuthEmailVerify400 = VerificationCodeExpiredError | VerificationCodeConsumedError;

export type PostAuthPasswordForgot200 = MFAPendingResponse | ForgotPasswordSuccessResponse;

export type PatchAuthPasswordReset400 = VerificationCodeExpiredError | VerificationCodeConsumedError | PasswordReuseNotAllowed;

export type PatchAuthPasswordReset404 = VerificationCodeNotFoundError | UserNotFoundError;

export type PostMfaVerifyBody = {
  /** The 6-digit one-time password (OTP) generated by the user's authenticator app or received via the selected MFA method.
 */
  code: string;
};

export type PostMfaVerify400 = MfaTemporarySecretExpiredError | MfaInvalidVerificationCodeError;

export type PatchMfaRevokeBody = {
  /** The 6-digit one-time password (OTP) generated by the user's authenticator app.   Must be valid at the time of request.
 */
  code: string;
};

export type PostMfaBackupCodeConsumeBody = {
  /** The valid unused backup code associated with the user's account. */
  backupCode: string;
};

export type PostMfaBackupCodeLoginBody = {
  /** The valid unused backup code associated with the user's account. */
  backupCode: string;
};

export type PostMfaVerifyLoginBody = {
  /** The 6-digit one-time password (OTP) generated by the user's authenticator app.   Must be valid at the time of request.
 */
  code: string;
};

export type PostMfaVerifyLogin400 = MfaNotEnabledError | MfaInvalidVerificationCodeError;

export type PostMfaVerifyForgotPasswordBody = {
  /** The 6-digit one-time password (OTP) generated by the user's authenticator app.   Must be valid at the time of request.
 */
  code: string;
};

export type PostMfaVerifyForgotPassword400 = MfaNotEnabledError | MfaInvalidVerificationCodeError;

export type PostPasskeyRegisterInitBody = {
  /** The display name of the user registering a passkey. */
  name: string;
  /** The email address of the user registering a passkey. */
  email: string;
};

export type PostPasskeyRegisterVerify401 = PasskeyChallengeSessionNotFoundError | PasskeyChallengeSessionExpiredError | PasskeyChallengeVerificationError;

export type PostPasskeyAuthenticateVerify200 = LoginEmailVerificationPendingResponse | LoginSuccessResponse;

export type PostPasskeyAuthenticateVerify401 = PasskeyChallengeSessionNotFoundError | PasskeyChallengeSessionExpiredError | PasskeyChallengeVerificationError | PasskeyNotFoundError;

export type PostPasskeyAddPasskeyVerifyUserid401 = PasskeyChallengeSessionNotFoundError | PasskeyChallengeSessionExpiredError | PasskeyChallengeVerificationError | PasskeyNotFoundError | AuthenticationTokenNotFoundError | AccessTokenTypeError | AuthenticationTokenUserNotFoundError | AuthenticationTokenInvalidSessionError | AuthenticationTokenSessionMismatchError | AuthenticationTokenInvalidTokenErorr | AuthenticationTokenExpiredError;

export type DeletePasskeyRemoveKeyVerifyUseridCredentialid401 = PasskeyChallengeSessionNotFoundError | PasskeyChallengeSessionExpiredError | PasskeyChallengeVerificationError | AuthenticationTokenNotFoundError | AccessTokenTypeError | AuthenticationTokenUserNotFoundError | AuthenticationTokenInvalidSessionError | AuthenticationTokenSessionMismatchError | AuthenticationTokenInvalidTokenErorr | AuthenticationTokenExpiredError;

export type GetOidcGoogleCallbackParams = {
/**
 * Authorization code returned by Google
 */
code: string;
/**
 * Unique state generated during the authorization request
 */
state: string;
};

export type GetOidcGoogleCallback400 = OIDCSessionExpiredError | OIDCSessionConsumedError;

export type GetGithubOidcAuthUrlParams = {
/**
 * Authorization code returned by Github
 */
code: string;
/**
 * Unique state generated during the authorization request
 */
state: string;
};

export type GetGithubOidcAuthUrl400 = OIDCSessionExpiredError | OIDCSessionConsumedError;

/**
 * This endpoint allows a new user to create an account using their email and password. After registration, the user must verify their email to complete the registration process successfully.
 * @summary Register a new user
 */
export const postAuthRegister = <TData = AxiosResponse<RegistrationSuccessReponse>>(
    userRegistrationRequestBody: UserRegistrationRequestBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/auth/register`,
      userRegistrationRequestBody,options
    );
  }

/**
 * This endpoint allows an existing user to log in using their email and password. Upon successful authentication, an access token (and optionally a refresh token) is returned. If the user has two-factor authentication enabled, additional steps may be required to complete the login process.

 * @summary Authenticate a user with email and password
 */
export const postAuthLogin = <TData = AxiosResponse<PostAuthLogin200>>(
    userLoginRequestBody: UserLoginRequestBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/auth/login`,
      userLoginRequestBody,options
    );
  }

/**
 * Verifies a user's email address using a verification token sent via email. Upon successful verification, the user's account is marked as confirmed, allowing them to complete the login process or other protected actions.

 * @summary Authenticate a user with email and password
 */
export const postAuthEmailVerify = <TData = AxiosResponse<EmailConfirmedSuccessResponse>>(
    postAuthEmailVerifyBody: PostAuthEmailVerifyBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/auth/email/verify`,
      postAuthEmailVerifyBody,options
    );
  }

/**
 * Initiates the password reset process for a user by submitting their email address.  If the user has two-factor authentication (MFA) enabled, an MFA verification step will be required before sending the password reset instructions. Otherwise, a password reset email will be sent directly.

 * @summary Request a password reset for a user account
 */
export const postAuthPasswordForgot = <TData = AxiosResponse<PostAuthPasswordForgot200>>(
    forgotPasswordRequestBody: ForgotPasswordRequestBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/auth/password/forgot`,
      forgotPasswordRequestBody,options
    );
  }

/**
 * Completes the password reset process for a user account using a valid verification code.   The request must include the verification code (typically received via email) and the new password.   Upon successful verification, the user's password is updated, existing authentication cookies are cleared,   and the user is advised to log in again. If the password reset was not initiated by the user, they are encouraged   to contact support immediately. The operation also records contextual information such as IP address and user agent   for security auditing purposes.

 * @summary Complete the password reset process
 */
export const patchAuthPasswordReset = <TData = AxiosResponse<ResetPasswordSuccessResponse>>(
    resetPasswordRequestBody: ResetPasswordRequestBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/auth/password/reset`,
      resetPasswordRequestBody,options
    );
  }

/**
 * Issues a new access token (and optionally a new refresh token) for an authenticated session.   The request must include a valid **refresh token** stored in the user's HTTP-only cookie. If the refresh token is valid and the session is still active, a new access token will be returned and authentication cookies will be updated.   If the refresh token is expired, invalid, or mismatched, the session will be invalidated and all authentication cookies will be cleared to enforce re-authentication.   This endpoint ensures seamless session continuity while maintaining security best practices.

 * @summary Refresh the user's access token using a valid refresh token
 */
export const getAuthRefresh = <TData = AxiosResponse<RefreshTokenEndpointSuccessResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/auth/refresh`,options
    );
  }

/**
 * Terminates the current authenticated session by invalidating all active authentication tokens and clearing related cookies (`accessToken`, `refreshToken`).   This ensures that both the access token and any linked refresh token can no longer be used.   The endpoint is typically called when a user explicitly logs out or when a session needs to be forcefully closed for security reasons.   Requires a valid access token cookie for authentication and session validation.   After a successful logout, the client should remove any cached session state and redirect the user to a login page.

 * @summary Log out the authenticated user and invalidate the current session
 */
export const postAuthLogout = <TData = AxiosResponse<LogoutSuccessResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/auth/logout`,undefined,options
    );
  }

/**
 * Registers a new user account by sending a **magic link** to the provided email address. 
The user can complete the signup process by clicking the link in the verification email. 
If the email is already associated with an existing account, the request will be rejected.  
This flow is typically used when passwordless authentication is enabled for the application.

 * @summary Register a new user using a magic link
 */
export const postMagicLinkSignup = <TData = AxiosResponse<MagicLinkSignUpSuccessResponse>>(
    magicLinkSignUpRequestBody: MagicLinkSignUpRequestBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/magic-link/signup`,
      magicLinkSignUpRequestBody,options
    );
  }

/**
 * Initiates a passwordless sign-in flow by sending a magic link to the user email address. 
The user can authenticate by clicking the link received in their inbox. 
If the email is not associated with any account, the request will fail with a 404 response. 
This endpoint is typically used in passwordless authentication systems.

 * @summary Sign in a user using a magic link
 */
export const postMagicLinkSignin = <TData = AxiosResponse<MagicLinkSignInSuccessResponse>>(
    magicLinkSignInRequestBody: MagicLinkSignInRequestBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/magic-link/signin`,
      magicLinkSignInRequestBody,options
    );
  }

/**
 * Resends a new generated magic link to the user's email address. 
This endpoint can be used when the user did not receive or accidentally deleted 
the original magic link for verification or sign-in. 
If the email does not correspond to an existing user, the request will fail with a 404 response. 
This operation is commonly used in passwordless authentication systems to handle failed or lost verification emails.

 * @summary Resend a magic link for email verification or sign-in
 */
export const postMagicLinkResend = <TData = AxiosResponse<MagicLinkSignInSuccessResponse>>(
    magicLinkSignInRequestBody: MagicLinkSignInRequestBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/magic-link/resend`,
      magicLinkSignInRequestBody,options
    );
  }

/**
 * Verifies a user's email or signs them in by validating the provided magic link token. 
This endpoint is typically triggered when the user clicks on the magic link sent to their email. 
Upon successful verification, authentication cookies or tokens are issued to establish the session.

 * @summary Verify a user's email using a magic link token
 */
export const getMagicLinkVerifyToken = <TData = AxiosResponse<LoginSuccessResponse>>(
    token: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/magic-link/verify/${token}`,options
    );
  }

/**
 * Initiates the setup process for Multi-Factor Authentication (MFA) using TOTP (Time-Based One-Time Password). 
Returns a temporary secret key and a QR code that the user can scan in their authenticator app (e.g., Google Authenticator, Authy). 
The temporary secret must be verified by the user to finalize MFA enrollment. 
This endpoint requires the user to be authenticated via a valid access token cookie.

 * @summary Retrieve temporary TOTP secret and QR code for MFA setup
 */
export const getMfaSetup = <TData = AxiosResponse<MfaSetupResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/mfa/setup`,options
    );
  }

/**
 * Verifies the multi-factor authentication (MFA) code provided by the user. This step is required after MFA setup or during a login flow to validate the one-time code generated by the authenticator app or sent via email/SMS. Upon successful verification, the MFA setup is confirmed or the login session is allowed.

 * @summary Verify the MFA code for a user
 */
export const postMfaVerify = <TData = AxiosResponse<MFAVerifySetupSuccessResponse>>(
    postMfaVerifyBody: PostMfaVerifyBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/mfa/verify`,
      postMfaVerifyBody,options
    );
  }

/**
 * Revokes (disables) Two-Factor Authentication (2FA) for the authenticated user.   The user must provide a valid MFA verification code generated by their authenticator app.   Once verified, the user's 2FA secret and backup codes will be permanently removed.

 * @summary Disable (revoke) Two-Factor Authentication (2FA) for the current user
 */
export const patchMfaRevoke = <TData = AxiosResponse<MFARevokeSuccessReponse>>(
    patchMfaRevokeBody: PatchMfaRevokeBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/mfa/revoke`,
      patchMfaRevokeBody,options
    );
  }

/**
 * Disables Multi-Factor Authentication (2FA) for the currently authenticated user using one of their previously generated backup codes.   This endpoint can be used when the user no longer has access to their authenticator app but still possesses a valid backup code.   Upon successful verification of the provided backup code, all remaining backup codes are invalidated, the MFA secret is removed, and 2FA is fully disabled for the account.

 * @summary Disable Two-Factor Authentication (2FA) using a backup code
 */
export const postMfaBackupCodeConsume = <TData = AxiosResponse<MFARevokeSuccessReponse>>(
    postMfaBackupCodeConsumeBody: PostMfaBackupCodeConsumeBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/mfa/backup-code/consume`,
      postMfaBackupCodeConsumeBody,options
    );
  }

/**
 * Authenticates a user by consuming one of their valid MFA backup codes. This endpoint is typically used when a user cannot access their authenticator app but has saved backup codes.   Upon successful verification, a new authenticated session is created, access and refresh tokens are issued, and the used backup code is invalidated (removed from the account).   The `mfaToken` cookie used during the MFA flow is cleared upon successful login.

 * @summary Log in using a backup code
 */
export const postMfaBackupCodeLogin = <TData = AxiosResponse<LoginSuccessResponse>>(
    postMfaBackupCodeLoginBody: PostMfaBackupCodeLoginBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/mfa/backup-code/login`,
      postMfaBackupCodeLoginBody,options
    );
  }

/**
 * Validates the one-time MFA code provided by the user during the login process.   This endpoint finalizes the multi-factor authentication (MFA) login flow by verifying the 6-digit time-based one-time password (TOTP) generated by the user‚Äôs authenticator app.   Upon successful verification, a new authenticated session is created, and both access and refresh tokens are issued. The temporary `mfaToken` cookie is cleared once login is complete.

 * @summary Verify MFA code during login
 */
export const postMfaVerifyLogin = <TData = AxiosResponse<LoginSuccessResponse>>(
    postMfaVerifyLoginBody: PostMfaVerifyLoginBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/mfa/verify/login`,
      postMfaVerifyLoginBody,options
    );
  }

/**
 * Verifies the one-time MFA code submitted by the user in order to proceed with a password reset.   Upon successful verification, a password reset email is sent to the user's registered email address with a link to complete the password change process.   This endpoint also clears the temporary MFA token cookie to prevent reuse.

 * @summary Verify MFA code for password reset
 */
export const postMfaVerifyForgotPassword = <TData = AxiosResponse<MFARequestChangePasswordSuccessReponse>>(
    postMfaVerifyForgotPasswordBody: PostMfaVerifyForgotPasswordBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/mfa/verify/forgot-password`,
      postMfaVerifyForgotPasswordBody,options
    );
  }

/**
 * Starts the registration process for a new user using passwordless passkey authentication.  The client provides the user's name and email address. If the email is not already registered, the server generates a **PublicKeyCredentialCreationOptions** object required by the WebAuthn API. This object includes a challenge, relying party information, user details, allowed algorithms, and authenticator selection criteria. It must be sent back to the client to complete the registration on the authenticator (device or platform). The server also stores a temporary PasskeyChallengeSession to track the challenge for later verification.

 * @summary Initialize a passkey registration session
 */
export const postPasskeyRegisterInit = <TData = AxiosResponse<PasskeyGenerateSignUpSessionSuccessResponse>>(
    postPasskeyRegisterInitBody: PostPasskeyRegisterInitBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/passkey/register/init`,
      postPasskeyRegisterInitBody,options
    );
  }

/**
 * Verifies a passkey registration session provided by the client to complete the user signup process.
The client must provide a `PasskeyRegistrationResponse` object containing the credential information generated during the passkey registration initiation.

 * @summary Verify a passkey registration session and complete user signup
 */
export const postPasskeyRegisterVerify = <TData = AxiosResponse<RegistrationSuccessReponse>>(
    passkeyCompletRegistrationRequestBody: PasskeyCompletRegistrationRequestBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/passkey/register/verify`,
      passkeyCompletRegistrationRequestBody,options
    );
  }

/**
 * Initializes a new **WebAuthn passkey authentication session** for a user who wants to sign in using a registered passkey.   The endpoint generates a new WebAuthn **authentication challenge** and returns a set of `PublicKeyCredentialRequestOptions` that the frontend must pass to the browser's WebAuthn API (`navigator.credentials.get`).  
The generated challenge is stored securely in the backend and will later be verified during the `/passkey/authenticate/verify` step.   No user identifier is required at this stage, as the passkey authenticator handles user identification during the authentication process.
This endpoint should be called from the frontend **before** invoking the browser WebAuthn API.
--- **Typical flow:** 1. Frontend calls `POST /passkey/authenticate/init` 2. Backend generates and stores challenge + session 3. Frontend receives `publicKeyCredentialRequestOptions` 4. Frontend calls `navigator.credentials.get(options)` with those options 5. The result is sent to `/passkey/authenticate/verify` for final verification

 * @summary Initialize a passkey authentication (sign-in) session
 */
export const postPasskeyAuthenticateInit = <TData = AxiosResponse<PasskeyGenerateSignInSessionSuccessResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/passkey/authenticate/init`,undefined,options
    );
  }

/**
 * Completes the **passkey-based sign-in process** by verifying the WebAuthn authentication response 
returned by the browser after calling `navigator.credentials.get()`.  

This endpoint:
  - Validates the cryptographic response (challenge, signature, authenticator data)
  - Ensures the passkey session is still valid and not consumed
  - Confirms that the user exists and is eligible for login
  - Creates a new authenticated session and issues secure access and refresh tokens

On success, the user is authenticated, tokens are issued, and authentication cookies are set.  
If the user's email has not yet been verified, the endpoint returns a pending verification response instead of logging in.

 * @summary Verify a passkey authentication response and complete user login
 */
export const postPasskeyAuthenticateVerify = <TData = AxiosResponse<PostPasskeyAuthenticateVerify200>>(
    passkeyCompletAuthenticationRequestBody: PasskeyCompletAuthenticationRequestBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/passkey/authenticate/verify`,
      passkeyCompletAuthenticationRequestBody,options
    );
  }

/**
 * Initializes a **WebAuthn passkey registration session** that allows a logged-in user to securely add a new passkey to their account.  

This endpoint performs the following steps:
  1. Validates the authenticated user and checks that they match the `{userid}` path parameter.
  2. Retrieves existing passkeys associated with the account to prevent re-registration of the same authenticator.
  3. Generates a new **WebAuthn PublicKeyCredentialCreationOptions** object (challenge, relying party info, user identity, supported algorithms, etc.).
  4. Persists the challenge session in the database with the `"add-new-key"` purpose for later verification.

The client (frontend) should use the returned `publicKeyOpts` object as input for the `navigator.credentials.create()` call in the browser.

This route requires a valid **access token cookie** for authentication.

 * @summary Initialize a new passkey registration session for an authenticated user
 */
export const postPasskeyAddPasskeyInitUserid = <TData = AxiosResponse<PasskeyGenerateSignUpSessionSuccessResponse>>(
    userid: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/passkey/add-passkey/init/${userid}`,undefined,options
    );
  }

/**
 * Completes the registration of a new **Passkey** for the currently authenticated user.  
This endpoint verifies the passkey attestation response generated by the client after initiating the "Add new passkey" process.  

Once verification succeeds:
  - The passkey is securely registered and linked to the user‚Äôs account.
  - The corresponding challenge session is marked as consumed.
  - A success response containing the stored passkey details is returned.

Access to this endpoint requires a valid authenticated session and a matching user ID in the path parameter.

 * @summary Verify and finalize new Passkey registration
 */
export const postPasskeyAddPasskeyVerifyUserid = <TData = AxiosResponse<PasskeyAddedSuccessResponse>>(
    userid: string,
    passkeyCompletRegistrationRequestBody: PasskeyCompletRegistrationRequestBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/passkey/add-passkey/verify/${userid}`,
      passkeyCompletRegistrationRequestBody,options
    );
  }

/**
 * This endpoint initiates the process to remove a passkey associated with a user's account.  
The user must be authenticated and authorized to remove a specific passkey, identified by the `credentialid`.  
Upon successful initiation, a passkey removal session is created, and options for the passkey removal request (such as challenge data) are returned.  
The challenge session is created to ensure that the request is authentic, and no unauthorized changes can be made to the passkey list.

**Important:** 
- The user must be authenticated using a valid access token (passed via cookies).
- The `userid` and `credentialid` parameters must match the currently authenticated user and the passkey being removed.

 * @summary Initiate Passkey removal for a user
 */
export const postPasskeyRemoveKeyInitUseridCredentialid = <TData = AxiosResponse<PasskeyGenerateRemoveKeySuccessResponse>>(
    userid: string,
    credentialid: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/passkey/remove-key/init/${userid}/${credentialid}`,undefined,options
    );
  }

/**
 * This endpoint allows the authenticated user to remove a specific passkey credential from their account. The request must include the user ID and the credential ID of the passkey to be removed. The user can only remove their own passkeys. This action requires authentication and the provided session must be valid. If successful, the passkey will be permanently deleted from the system, and the session used for verification will be marked as consumed.

 * @summary Remove a passkey credential from a user's account
 */
export const deletePasskeyRemoveKeyVerifyUseridCredentialid = <TData = AxiosResponse<PasskeyRemovedSuccessResponse>>(
    userid: string,
    credentialid: string,
    passkeyCompletAuthenticationRequestBody: PasskeyCompletAuthenticationRequestBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/passkey/remove-key/verify/${userid}/${credentialid}`,{data:
      passkeyCompletAuthenticationRequestBody, ...options}
    );
  }

/**
 * This endpoint allows you to retrieve all passkeys that are associated with a specific user by their unique `userid`.  The user must be authenticated and the `userid` in the path must match the authenticated user's ID to prevent unauthorized access. Each passkey returned will include essential details such as the credential ID, the associated provider (`aaguid`), the date it was created,  and the last time it was used. The response also includes metadata with the total count of passkeys retrieved.

 * @summary Retrieve all passkeys associated with a user.
 */
export const getPasskeyAllUserid = <TData = AxiosResponse<PasskeyGetAllPasskeyByUserIdSuccessResponse>>(
    userid: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/passkey/all/${userid}`,options
    );
  }

/**
 * Retrieves a list of all **active login sessions** associated with the authenticated user.   This endpoint allows a user to view all currently valid sessions across devices and browsers, helping with account activity monitoring and session management.  
Each returned session includes device information (`userAgent`), creation and expiration timestamps, and a boolean flag (`isCurrent`) indicating whether it corresponds to the current active session (the one used to make the request).  
Expired sessions are automatically filtered out and are **not included** in the response.

 * @summary Retrieve all active sessions for the authenticated user
 */
export const getSessionAll = <TData = AxiosResponse<GetAllSessionsSuccessResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/session/all`,options
    );
  }

/**
 * Retrieves the **current active session** for the authenticated user, based on the session ID stored in the request context.   This endpoint is primarily used to identify the session associated with the current request and to retrieve minimal user information .

 * @summary Retrieve the current user session
 */
export const getSession = <TData = AxiosResponse<GetCurrentSessionSuccessResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/session/`,options
    );
  }

/**
 * Deletes a specific user session identified by its ID.  The operation validates that the session exists and that the authenticated user has permission to delete it.  If the deleted session is the current session of the user, authentication cookies will be cleared, effectively logging the user out.
Responses include a success message and, if the current session was deleted, a `nextStep` indicating that the user should be redirected to the login page.
Possible errors:
  - 403 Forbidden: If the user tries to delete a session that does not belong to them.
  - 404 Not Found: If the session ID does not exist.

 * @summary Delete a user session by ID
 */
export const deleteSessionId = <TData = AxiosResponse<DeleteSessionByIdSuccessResponse>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/session/${id}`,options
    );
  }

/**
 * Initiates the OAuth 2.0 Authorization Code Flow with PKCE for Google sign-in. This endpoint generates a unique `state` and `code_challenge`, stores them in the database as an OIDC session, and redirects the client to the Google OAuth 2.0 authorization endpoint.
The `state` is used to prevent CSRF attacks, and `code_challenge` is part of PKCE to enhance security.
**Behavior:** - Returns an HTTP 307 redirect to the Google authorization URL. - Sets caching headers to prevent storing sensitive information. - No JSON body is returned.
**Authorization URL parameters sent to Google:** - `access_type`: Requests offline access to receive refresh tokens (`offline`) - `response_type`: Expected response type (`code`) - `client_id`: Google OAuth Client ID - `scope`: Requested access scopes (`openid profile email`) - `redirect_uri`: Callback URL registered in Google OAuth App - `state`: Randomly generated string to prevent CSRF - `code_challenge` and `code_challenge_method`: PKCE parameters (`S256`)

 * @summary Generate Google OIDC authorization URL
 */
export const getOidcGoogleAuthUrl = <TData = AxiosResponse<unknown>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/oidc/google/auth-url`,options
    );
  }

/**
 * Handles the callback from Google after user authorization. Expects `code` and `state` query parameters returned by Google. 
**Flow:** 1. Verify that the `state` exists, has not expired, and has not been consumed. 2. Exchange the authorization code for tokens (access token, refresh token, ID token). 3. Validate the ID token against Google's JWKS endpoint and verify claims. 4. Create or find a corresponding user in the local database. 5. Set authentication cookies (`accessToken` and `refreshToken`). 6. Return a JSON response indicating successful login.

 * @summary Authenticate user via Google OIDC callback
 */
export const getOidcGoogleCallback = <TData = AxiosResponse<LoginSuccessResponse>>(
    params: GetOidcGoogleCallbackParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/oidc/google/callback`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Initiates the OAuth 2.0 Authorization Code Flow with PKCE for GitHub sign-in. This endpoint generates a unique `state` and `code_challenge`, stores them in the database as an OIDC session, and redirects the client to the GitHub OAuth 2.0 authorization endpoint.
The `state` is used to prevent CSRF attacks, and `code_challenge` is part of PKCE to enhance security.
**Behavior:** - Returns an HTTP 307 redirect to the GitHub authorization URL. - Sets caching headers to prevent storing sensitive information. - No JSON body is returned.
**Authorization URL parameters sent to GitHub:** - `client_id`: GitHub OAuth App client ID - `redirect_uri`: Callback URI registered in GitHub OAuth App - `scope`: Requested access scopes (`user read:user user:email`) - `state`: Randomly generated string to prevent CSRF - `code_challenge` and `code_challenge_method`: PKCE parameters - `allow_signup`: Whether GitHub should prompt to create a new account (`true`) - `access_type`: Offline access for refresh tokens (`offline`) - `prompt`: Account selection prompt (`select_account`)

 * @summary Generate GitHub OIDC authorization URL
 */
export const getOidcGithubAuthUrl = <TData = AxiosResponse<unknown>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/oidc/github/auth-url`,options
    );
  }

/**
 * Handles the callback from Github after user authorization. Expects `code` and `state` query parameters returned by Github. 
**Flow:** 1. Verify that the `state` exists, has not expired, and has not been consumed. 2. Exchange the authorization code for tokens (access token, refresh token, ID token). 3. Validate the ID token against Github's JWKS endpoint and verify claims. 4. Create or find a corresponding user in the local database. 5. Set authentication cookies (`accessToken` and `refreshToken`). 6. Return a JSON response indicating successful login.

 * @summary Authenticate user via Github OIDC callback
 */
export const getGithubOidcAuthUrl = <TData = AxiosResponse<LoginSuccessResponse>>(
    params: GetGithubOidcAuthUrlParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/oidc/github/callback`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

export type PostAuthRegisterResult = AxiosResponse<RegistrationSuccessReponse>
export type PostAuthLoginResult = AxiosResponse<PostAuthLogin200>
export type PostAuthEmailVerifyResult = AxiosResponse<EmailConfirmedSuccessResponse>
export type PostAuthPasswordForgotResult = AxiosResponse<PostAuthPasswordForgot200>
export type PatchAuthPasswordResetResult = AxiosResponse<ResetPasswordSuccessResponse>
export type GetAuthRefreshResult = AxiosResponse<RefreshTokenEndpointSuccessResponse>
export type PostAuthLogoutResult = AxiosResponse<LogoutSuccessResponse>
export type PostMagicLinkSignupResult = AxiosResponse<MagicLinkSignUpSuccessResponse>
export type PostMagicLinkSigninResult = AxiosResponse<MagicLinkSignInSuccessResponse>
export type PostMagicLinkResendResult = AxiosResponse<MagicLinkSignInSuccessResponse>
export type GetMagicLinkVerifyTokenResult = AxiosResponse<LoginSuccessResponse>
export type GetMfaSetupResult = AxiosResponse<MfaSetupResponse>
export type PostMfaVerifyResult = AxiosResponse<MFAVerifySetupSuccessResponse>
export type PatchMfaRevokeResult = AxiosResponse<MFARevokeSuccessReponse>
export type PostMfaBackupCodeConsumeResult = AxiosResponse<MFARevokeSuccessReponse>
export type PostMfaBackupCodeLoginResult = AxiosResponse<LoginSuccessResponse>
export type PostMfaVerifyLoginResult = AxiosResponse<LoginSuccessResponse>
export type PostMfaVerifyForgotPasswordResult = AxiosResponse<MFARequestChangePasswordSuccessReponse>
export type PostPasskeyRegisterInitResult = AxiosResponse<PasskeyGenerateSignUpSessionSuccessResponse>
export type PostPasskeyRegisterVerifyResult = AxiosResponse<RegistrationSuccessReponse>
export type PostPasskeyAuthenticateInitResult = AxiosResponse<PasskeyGenerateSignInSessionSuccessResponse>
export type PostPasskeyAuthenticateVerifyResult = AxiosResponse<PostPasskeyAuthenticateVerify200>
export type PostPasskeyAddPasskeyInitUseridResult = AxiosResponse<PasskeyGenerateSignUpSessionSuccessResponse>
export type PostPasskeyAddPasskeyVerifyUseridResult = AxiosResponse<PasskeyAddedSuccessResponse>
export type PostPasskeyRemoveKeyInitUseridCredentialidResult = AxiosResponse<PasskeyGenerateRemoveKeySuccessResponse>
export type DeletePasskeyRemoveKeyVerifyUseridCredentialidResult = AxiosResponse<PasskeyRemovedSuccessResponse>
export type GetPasskeyAllUseridResult = AxiosResponse<PasskeyGetAllPasskeyByUserIdSuccessResponse>
export type GetSessionAllResult = AxiosResponse<GetAllSessionsSuccessResponse>
export type GetSessionResult = AxiosResponse<GetCurrentSessionSuccessResponse>
export type DeleteSessionIdResult = AxiosResponse<DeleteSessionByIdSuccessResponse>
export type GetOidcGoogleAuthUrlResult = AxiosResponse<unknown>
export type GetOidcGoogleCallbackResult = AxiosResponse<LoginSuccessResponse>
export type GetOidcGithubAuthUrlResult = AxiosResponse<unknown>
export type GetGithubOidcAuthUrlResult = AxiosResponse<LoginSuccessResponse>
