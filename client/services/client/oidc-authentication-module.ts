/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * API for Password, Passkey, Magic Link, and OIDC Authentication
 * API for user registration and authentication using multiple methods: username/password with capability of 2fa, passkey (WebAuthn), magic link, and OIDC providers (Google, GitHub, etc.).

 * OpenAPI spec version: 1.0.0
 */
import type {
  GetOIDCAuthUrlSuccessResponse,
  LoginSuccessResponse,
  OidcGithubCallbackGetQueryFnParams,
  OidcGoogleCallbackGetQueryFnParams
} from './client.schemas';

import { customAxiosInstance } from '../../config/axios.config';



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];


  /**
 * Initiates the OAuth 2.0 Authorization Code Flow with PKCE for Google sign-in. This endpoint generates a unique `state` and `code_challenge`, stores them in the database as an OIDC session, and redirects the client to the Google OAuth 2.0 authorization endpoint.
The `state` is used to prevent CSRF attacks, and `code_challenge` is part of PKCE to enhance security.
**Behavior:** - Returns an HTTP 307 redirect to the Google authorization URL. - Sets caching headers to prevent storing sensitive information. - No JSON body is returned.
**Authorization URL parameters sent to Google:** - `access_type`: Requests offline access to receive refresh tokens (`offline`) - `response_type`: Expected response type (`code`) - `client_id`: Google OAuth Client ID - `scope`: Requested access scopes (`openid profile email`) - `redirect_uri`: Callback URL registered in Google OAuth App - `state`: Randomly generated string to prevent CSRF - `code_challenge` and `code_challenge_method`: PKCE parameters (`S256`)

 * @summary Generate Google OIDC authorization URL
 */
export const oidcGoogleAuthUrlGetQueryFn = (
    
 options?: SecondParameter<typeof customAxiosInstance<GetOIDCAuthUrlSuccessResponse>>,) => {
      return customAxiosInstance<GetOIDCAuthUrlSuccessResponse>(
      {url: `/oidc/google/auth-url`, method: 'GET'
    },
      options);
    }
  /**
 * Handles the callback from Google after user authorization. Expects `code` and `state` query parameters returned by Google. 
**Flow:** 1. Verify that the `state` exists, has not expired, and has not been consumed. 2. Exchange the authorization code for tokens (access token, refresh token, ID token). 3. Validate the ID token against Google's JWKS endpoint and verify claims. 4. Create or find a corresponding user in the local database. 5. Set authentication cookies (`accessToken` and `refreshToken`). 6. Return a JSON response indicating successful login.

 * @summary Authenticate user via Google OIDC callback
 */
export const oidcGoogleCallbackGetQueryFn = (
    params: OidcGoogleCallbackGetQueryFnParams,
 options?: SecondParameter<typeof customAxiosInstance<LoginSuccessResponse>>,) => {
      return customAxiosInstance<LoginSuccessResponse>(
      {url: `/oidc/google/callback`, method: 'GET',
        params
    },
      options);
    }
  /**
 * Initiates the OAuth 2.0 Authorization Code Flow with PKCE for GitHub sign-in. This endpoint generates a unique `state` and `code_challenge`, stores them in the database as an OIDC session, and redirects the client to the GitHub OAuth 2.0 authorization endpoint.
The `state` is used to prevent CSRF attacks, and `code_challenge` is part of PKCE to enhance security.
**Behavior:** - Returns an HTTP 307 redirect to the GitHub authorization URL. - Sets caching headers to prevent storing sensitive information. - No JSON body is returned.
**Authorization URL parameters sent to GitHub:** - `client_id`: GitHub OAuth App client ID - `redirect_uri`: Callback URI registered in GitHub OAuth App - `scope`: Requested access scopes (`user read:user user:email`) - `state`: Randomly generated string to prevent CSRF - `code_challenge` and `code_challenge_method`: PKCE parameters - `allow_signup`: Whether GitHub should prompt to create a new account (`true`) - `access_type`: Offline access for refresh tokens (`offline`) - `prompt`: Account selection prompt (`select_account`)

 * @summary Generate GitHub OIDC authorization URL
 */
export const oidcGithubAuthUrlGetQueryFn = (
    
 options?: SecondParameter<typeof customAxiosInstance<GetOIDCAuthUrlSuccessResponse>>,) => {
      return customAxiosInstance<GetOIDCAuthUrlSuccessResponse>(
      {url: `/oidc/github/auth-url`, method: 'GET'
    },
      options);
    }
  /**
 * Handles the callback from Github after user authorization. Expects `code` and `state` query parameters returned by Github. 
**Flow:** 1. Verify that the `state` exists, has not expired, and has not been consumed. 2. Exchange the authorization code for tokens (access token, refresh token, ID token). 3. Validate the ID token against Github's JWKS endpoint and verify claims. 4. Create or find a corresponding user in the local database. 5. Set authentication cookies (`accessToken` and `refreshToken`). 6. Return a JSON response indicating successful login.

 * @summary Authenticate user via Github OIDC callback
 */
export const oidcGithubCallbackGetQueryFn = (
    params: OidcGithubCallbackGetQueryFnParams,
 options?: SecondParameter<typeof customAxiosInstance<LoginSuccessResponse>>,) => {
      return customAxiosInstance<LoginSuccessResponse>(
      {url: `/oidc/github/callback`, method: 'GET',
        params
    },
      options);
    }
  export type OidcGoogleAuthUrlGetQueryFnResult = NonNullable<Awaited<ReturnType<typeof oidcGoogleAuthUrlGetQueryFn>>>
export type OidcGoogleCallbackGetQueryFnResult = NonNullable<Awaited<ReturnType<typeof oidcGoogleCallbackGetQueryFn>>>
export type OidcGithubAuthUrlGetQueryFnResult = NonNullable<Awaited<ReturnType<typeof oidcGithubAuthUrlGetQueryFn>>>
export type OidcGithubCallbackGetQueryFnResult = NonNullable<Awaited<ReturnType<typeof oidcGithubCallbackGetQueryFn>>>
